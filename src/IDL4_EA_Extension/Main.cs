/*********************************************************************************************
Copyright 2015 Real-Time Innovations, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
**********************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;


/* For the Sparx Automation APIs see:
 * http://bellekens.com/2011/01/29/tutorial-create-your-first-c-enterprise-architect-addin-in-10-minutes/
 * https://alexatnet.com/articles/creating-addin-for-sparx-enterprise-architect
 * http://blog.sparxsystems.eu/2015/05/the-enterprise-architect-object-model-ea-api/
 * http://bellekens.com/writing-ea-add-ins/
 */

using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using EA;

namespace IDL4_EA_Extension
{
    public class IDLGenAction : UserActionInterface
    {
        private EA.Repository _currentRepository = null;
        private TextOutputInterface _currentOutput = null;
        private HashSet<string> _uncheckedElements = null;
        private IDLClassSelector _classSelector = null;

        public void Initialize(EA.Repository repository, TextOutputInterface output, IDLClassSelector classSelector,
            HashSet<string> uncheckedElements)
        {
            _currentRepository = repository;
            _currentOutput = output;
            _uncheckedElements = uncheckedElements;
            _classSelector = classSelector;
            this.OnIdlVersionAction(IDLVersions.defaultVersion);
            this.OnIdlMappingDetailAction(IDLVersions.defaultMappingDetails);
        }

        public void OnCodegenAction()
        {
            Main.GenIDL(_currentRepository, false, _currentOutput, _uncheckedElements);
        }

        public void OnSaveAction(string filePath)
        {
            String[] preambleLines = {
               "/*",
               " *  IDL file generated by RTI Connext DDS Enterprise Architect IDL 4 Add-in version 1.0",
               " *      Enterprise Architect File:  " + _currentRepository.ConnectionString,
               " *      Date: " + DateTime.Now.ToString(),
               " */",
               " "
            };

            _currentOutput.SaveToFile(filePath, preambleLines);
        }

        public void OnSelectAction(TreeNode treeNode)
        {
            OnDebugAction("Selected Node: " + treeNode.FullPath);
            Main.GenIDL_Preview(_currentRepository, _currentOutput, _uncheckedElements, treeNode.FullPath);
        }

        public void OnCheckAction(TreeNode treeNode)
        {
            // Remember whether it is uncheked or not
            if (treeNode.Checked)
            {
                _uncheckedElements.Remove(treeNode.FullPath);
            }
            else
            {
                _uncheckedElements.Add(treeNode.FullPath);
            }
        }

        public void OnIdlVersionAction( IDLVersion ver )
        {
            _currentOutput.Clear();

            Main.setIdlVersion(ver.Value);
        }

        public void OnIdlMappingDetailAction(IDLMappingDetail detail)
        {
            _currentOutput.Clear();

            Main.setIdlMappingDetail(detail.Value);
        }

        public void OnDebugAction(string text)
        {
            _currentOutput.OutputTextLine(text);
        }
    }

    /* This is a helper class to resolve a connector from the perspective of one of the
     * two elements that terminate the connector.
     * It resolves
     * - The referenced elementID
     * - The two connectors ends. "source" and "refernced element" 
     */
    class ReferenceDescriptor
    {
        public ReferenceDescriptor()
        {
            sourceElemEnd     = null;
            referencedElemEnd = null;
            referencedElemId  = 0;
            shouldBeIncludedInSourceElemClass = false;
            explanation       = null;
        }
        public ConnectorEnd  sourceElemEnd;
        public ConnectorEnd  referencedElemEnd;
        public int           referencedElemId;
        public bool          shouldBeIncludedInSourceElemClass;
        String               explanation;
    };

    [ComVisible(true)]
    public class Main
    {

        private const String IDL_GENERATOR_REVISION = "1.9";
        private const String MENU_ROOT_RTI_CONNEXT  = "- IDL4  (RTI Connext DDS)";
        private const String MENU_ITEM_GENERATE_IDL = "Generate IDL ...";

        private static int idlVersion = IDLVersions.defaultVersion.Value;
        private static int idlMappingDetail = IDLVersions.defaultMappingDetails.Value;



        // Called Before EA starts to check Add-In Exists
        public string EA_Connect(Repository repository)
        {
            // nothing special
            return "EaProjectStats.AddIn - connected";
        }
        // EA calls this operation when it exists. Can be used to do some cleanup work.
        public void EA_Disconnect()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        // Called when user Click Add-Ins Menu item.
        public object EA_GetMenuItems(Repository repository,
            string location, string menuName)
        {
            switch (menuName)
            {
                case "":
                    return MENU_ROOT_RTI_CONNEXT;
                case MENU_ROOT_RTI_CONNEXT:
                    return MENU_ITEM_GENERATE_IDL;
            }
            return "";
        }

        // Sets the state of the menu depending if there is
        // an active project or not
        static bool EA_IsProjectOpen(Repository repository)
        {
            try
            {
                return null != repository.Models;
            }
            catch
            {
                return false;
            }
        }

        // Called once Menu has been opened to see what menu
        // items are active.
        public void EA_GetMenuState(Repository repository,
            string location, string menuName, string itemName,
            ref bool isEnabled, ref bool isChecked)
        {
            if (EA_IsProjectOpen(repository))
            {
                if (itemName == MENU_ROOT_RTI_CONNEXT)
                    isEnabled = true;
            }
            else
                // If no open project, disable all menu options
                isEnabled = false;
        }

        // Called when user makes a selection in the menu.
        // This is your main exit point to the rest of your Add-in
        public void EA_MenuClick(Repository repository,
            string location, string menuName, string itemName)
        {

            switch (itemName)
            {
                case MENU_ITEM_GENERATE_IDL:
                    IDLGenAction idlGenAction = new IDLGenAction();
                    IDLClassSelector idlClassSelector = new IDLClassSelector(idlGenAction);
                    TextBoxOutputAdapter output = new TextBoxOutputAdapter(idlClassSelector.getTextBox());
                    HashSet<string> uncheckedElements = new HashSet<string>();
                    idlGenAction.Initialize(repository, output, idlClassSelector, uncheckedElements);

                   // GenerateIDL(repository, output);

                    PopulateRepositoryClassSelector(idlClassSelector, repository);
                    idlClassSelector.Text = "IDL4 (RTI Connext DDS) - Select classes for IDL generation - Plugin revision " + IDL_GENERATOR_REVISION;
                    idlClassSelector.Show();
                    //idlGenAction.OnCodegenAction();
                    break;
            }
        }

        public static void PopulatePackageClassesAndEnums(TreeNode packageTreeNode, Package package)
        {
           foreach (Element e in package.Elements)
            {
                if (IsClass(e) || IsElementEnum(e))
                {
                    TreeNode classNode = new TreeNode(e.Name);
                    classNode.Checked = true;
                    packageTreeNode.Nodes.Add(classNode);
                }
            }
        }

        /*
         * *** This feature is not fully implemented so it is not used.***
         * 
         * The longer term objective would be to use this event to re-sync all the classes/enum with the model but only
         * at that level, not recursively
         */
        public static void ClassSelector_TreeViewAfterExpand(object sender, TreeViewEventArgs e)
        {
            return;
        }

        public static void PopulateRepositoryClassSelector(IDLClassSelector classSelector, Repository repository)
        {
            TreeNodeCollection treeNodes = classSelector.getTreeView().Nodes;


            foreach (Package model in repository.Models)
            {
                TreeNode newNode = new TreeNode(model.Name);
                newNode.Checked = true;
                newNode.Expand();
                newNode.Tag = model.Name;
                treeNodes.Add(newNode);

                foreach (Package package in model.Packages)
                {
                    PopulateClassSelector(newNode, package);
                }
            }

            // Disble because feature is not fully implemeted yet
            //classSelector.getTreeView().AfterExpand += new TreeViewEventHandler(ClassSelector_TreeViewAfterExpand);
        }

        public static void PopulateClassSelector(TreeNode parentNode, Package package)
        {
            TreeNode packageNode = new TreeNode(package.Name);
            packageNode.Checked = true;
            packageNode.Tag = package.Name;  // Store the related package
            parentNode.Nodes.Add(packageNode);

            foreach (Package p in package.Packages)
            {
                PopulateClassSelector(packageNode, p);
            }

            PopulatePackageClassesAndEnums(packageNode, package);
            packageNode.Expand();
        }

        /** Finds a child of an EA Model element capturing exceptions raised if the child is not
         * found.
         *
         */
        private static Object EAUtil_FindChild(EA.Collection collection, String childName)
        {
            Object child = null;
            try {
                child = collection.GetByName(childName);
            }
            catch (Exception) {}

            return child;
        }

        internal static void GenIDL_Preview(Repository repository, TextOutputInterface output,
            HashSet<string> uncheckedElem, String fullPath)
        {
            char[] delimiterChars = { '\\'};
            String[] elementNames = fullPath.Split(delimiterChars);
            String pathToElement = "";

            if (elementNames.Length <= 1)
            {
                GenIDL(repository, true, output, uncheckedElem);
                return;
            }

            Package package = (Package)EAUtil_FindChild(repository.Models, elementNames[0]);
            if (package == null)
            {
                output.OutputTextLine("// Could not find selected package: \"" + fullPath + "\" in the model");
                return;
            }

            Package parentPackage = package;
            Element  classElem = null;
            for (int i = 1; i < elementNames.Length; ++i, parentPackage = package)
            {
                String elemName = elementNames[i];

                package = (Package)EAUtil_FindChild(parentPackage.Packages, elemName);

                if ((package == null) && (i == elementNames.Length - 1))
                {
                    classElem = (Element)EAUtil_FindChild(parentPackage.Elements, elemName);
                }
            }

            output.Clear();
            if (package == null && classElem == null)
            {
                output.OutputTextLine("// Could not find selected element: \"" + fullPath + "\" in the model");
                return;
            }

            pathToElement = elementNames[0];
            for (int i = 1; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("module " + IDL_NormalizeUserDefinedClassifierName(elementNames[i]) + " {  ");
                pathToElement += "\\" + elementNames[i];
            }

            output.OutputTextLine();
            if (package != null)
            {
                // display package
                // output.OutputTextLine("Displaying Package: " + package.Name);
                Dictionary<long, bool> moduleRelevance = new Dictionary<long, bool>();
                HashSet<long> dummyCompletedClases = new HashSet<long>();
                UpdateModuleRelevance(moduleRelevance, package, output);
                Main.GenIDL_ModuleFirstPass(repository, package, true,
                    output, elementNames.Length - 1, pathToElement, uncheckedElem, moduleRelevance, null);
                int generatedItemCount;
                Main.GenIDL_ModuleSecondPass(repository, package, true,
                    output, elementNames.Length - 1, pathToElement,
                    out generatedItemCount, uncheckedElem, moduleRelevance, dummyCompletedClases);
            }
            else if (classElem != null)
            {
                // display class
                // output.OutputTextLine("Displaying Class: " + classElem.Name);
                if (IsElementEnum(classElem))
                {
                    Main.GenIDL_Enum(repository, classElem, output, elementNames.Length - 1, uncheckedElem, pathToElement);
                }
                else
                {
                    Main.GenIDL_Class(repository, classElem, output, elementNames.Length - 1, uncheckedElem, pathToElement);
                 }
            }
            for (int i = 1; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("};");
            }
        }

        /** Outputs UML "primitive" types that are not primitive in IDL
         */
        private static void GenIDL_PrebuiltUMLTypes(TextOutputInterface output)
        {
            String builtinTypes =
                "module UML_Extension {\n" +
                "    typedef long long dateTime;" +
                "};\n";
            output.OutputTextLine(builtinTypes);
        }

        internal static void GenIDL(Repository repository, bool isPreview, TextOutputInterface output, HashSet<String> uncheckedElem)
        {
            output.Clear();

            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are UML builtin primitive types that are not primitive in IDL */");
            GenIDL_PrebuiltUMLTypes(output);
            output.OutputTextLine("");

            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are Types defined in the model */");
            output.OutputTextLine("");

            // moduleRelevance holds the modules relevant for IDL generation
            Dictionary<long, bool> moduleRelevance = new Dictionary<long, bool>();

            // completedClasses holds the classes for which code has been completely generated
            // such that we can generate code that depends on these classes
            HashSet<long> completedClasses = new HashSet<long>();

            foreach (Package model in repository.Models)
            {
                if ((!isPreview) && uncheckedElem.Contains(model.Name))
                {
                    // if unckecked skip this model
                    continue;
                }

                UpdateModuleRelevance(moduleRelevance, model, output);
            }

            foreach (Package model in repository.Models)
            {
                if ((!isPreview) && uncheckedElem.Contains(model.Name))
                {
                    // if unckecked skip this model
                    continue;
                }

                output.OutputTextLine("/* -----  Model: \"" + model.Name + "\"  ----- */");
                foreach (Package package in model.Packages)
                {
                    GenIDL_ModuleFirstPass(repository, package, false,
                        output, 0, model.Name, uncheckedElem, moduleRelevance, completedClasses);
                }
            }

            int notGeneratedClassCount = -1;        // Does not matter as long as it is < 0
            int previousNotGeneratedClassCount;

            do {
                previousNotGeneratedClassCount = notGeneratedClassCount;
                notGeneratedClassCount = 0;

                foreach (Package model in repository.Models)
                {
                    if ((!isPreview) && uncheckedElem.Contains(model.Name))
                    {
                        // if unckecked skip this model
                        continue;
                    }

                    foreach (Package package in model.Packages)
                    {
                        int generatedItemCount;
                        notGeneratedClassCount += GenIDL_ModuleSecondPass(repository, package, false,
                            output, 0, model.Name,
                            out generatedItemCount, uncheckedElem, moduleRelevance, completedClasses);
                    }
                }
            }
            while ( (notGeneratedClassCount > 0) && (notGeneratedClassCount != previousNotGeneratedClassCount) ) ;


            if (notGeneratedClassCount > 0 )
            {
                output.OutputTextLine("/* WARNING: " + notGeneratedClassCount + " classes could not be generated due to circular dependencies */");
                GenIDL_ReportUngeneratedClasses(repository, output, 0, uncheckedElem, moduleRelevance, completedClasses);
            }
        }


        private static void GenIDL_ReportUngeneratedClasses(Repository repository,
            TextOutputInterface output, int depth,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, HashSet<long> completedClasses)
        {

            output.OutputTextLine("/*");
            output.OutputTextLine("     (<package> , <class>)  depends on (<package> , <class>) by means of <relationship>");
            output.OutputTextLine("     ----------------------------------------------------------------------------------");
            foreach (Package model in repository.Models)
            {
                if (uncheckedElem.Contains(model.Name))
                {
                    // if unchecked skip this model
                    continue;
                }

                foreach (Package package in model.Packages)
                {
                    GenIDL_ReportUngeneratedClasses(repository, package, output, 0, model.Name, uncheckedElem, relevantModules, completedClasses);
                }
            }
            output.OutputTextLine("     -----------------------------------------------------------------------------------");
            output.OutputTextLine("*/");
        }

        private static void GenIDL_ReportUngeneratedClasses(Repository repository, Package package,
            TextOutputInterface output, int depth, String pathToElem,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, HashSet<long> completedClasses)
        {
            // if unchecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if (IsElementUnchecked(uncheckedElem, packageFullName))
            {
                return;
            }

            if (!IsModuleRelevant(relevantModules, package, output))
            {
                return;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);
            foreach (Element e in package.Elements)
            {
                if (!IsElementEnum(e))
                {
                    if ( ( completedClasses.Contains(e.ElementID) == false )
                        && GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, null) )
                    {
                        GenIDL_DependenciesAlreadyGenerated(repository, e, output, completedClasses, true);
                    }
                }
            }

            foreach (Package p in package.Packages)
            {
                GenIDL_ReportUngeneratedClasses(repository, p, output, depth + 1, packageFullName, uncheckedElem, relevantModules, completedClasses);
            }
        }

        private static bool IsXSDSimpleType(Element classElem)
        {
            //TODO: This is a very simplistic criteria. May need to be enhanced
            // See: http://sparxsystems.com/forums/smf/index.php/topic,30258.0.html

            return classElem.Genlinks.IndexOf("Parent=") != -1;
        }

        //TODO: IDL_XSDprimitive2IDLprimitive should be deprecated. Use IDL_NormalizeMemberTypeName() instead
        private static readonly string[] xsd_longTypes = new string[] { "long", "int", "integer", "negativeInteger", "nonPositiveInteger" };
        private static readonly string[] xsd_ulongTypes = new string[] { "unsigned long", "unsignedLong", "unsignedInt", "positiveInteger", "nonNegativeInteger" };
        private static readonly string[] xsd_ushortTypes    = new string[] { "unsigned short", "unsignedShort" };
        private static readonly string[] xsd_octetTypes     = new string[] { "octet", "byte", "unsignedByte", "sbyte" };
        private static readonly string[] xsd_stringTypes = new string[] { "string", "normalizedString", "hexBinary", "base64Binary" };
        private static readonly string[][] xsd_primtiveTypeVariations = {
                xsd_longTypes, xsd_ulongTypes, xsd_ushortTypes, xsd_octetTypes, xsd_stringTypes
            };

        private static String IDL_XSDprimitive2IDLprimitive(String xsdPrimitiveType)
        {
            for (int typeFamily = 0; typeFamily < xsd_primtiveTypeVariations.GetLength(0); ++typeFamily)
            {
                if (xsd_primtiveTypeVariations[typeFamily].Contains(xsdPrimitiveType))
                {
                    return xsd_primtiveTypeVariations[typeFamily][0];
                }
            }

            return xsdPrimitiveType;
        }

        private static void GenIDL_ClassTypedef(Element classElem, TextOutputInterface output, int depth)
        {

            // output.OutputTextLine(depth, "// Debug Genlinks: " + classElem.Genlinks);
            // output.OutputTextLine(depth, "// Debug EmbeddedElements count: " + classElem.EmbeddedElements.Count);

            // Look to see if this class is just an alias for another as would happen for an xsd:simpleType
            if ( !IsXSDSimpleType(classElem) ) {
                output.OutputTextLine(depth, "struct " + IDL_NormalizeUserDefinedClassifierName(classElem.Name) + ";");
                return;
            }

            // Else it is a XSD simpleType. Find the base type and generate a typedef for it
            String genLinks = classElem.Genlinks;
            String genLinksBaseClass = null;
            if (genLinks != null)
            {
                String parentIdentifier = "Parent=";
                int parentBeginIndex = genLinks.IndexOf(parentIdentifier);

                if (parentBeginIndex >= 0)
                {
                    parentBeginIndex += parentIdentifier.Length;
                    int parentEndIndex = genLinks.IndexOf(";", parentBeginIndex);
                    if (parentEndIndex < 0)
                    {
                        parentEndIndex = genLinks.Length;
                    }

                    genLinksBaseClass = genLinks.Substring(parentBeginIndex, parentEndIndex - parentBeginIndex);
                }
            }

            if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
            {
                output.OutputTextLine(depth, "/* Mapping to typedef because generated links are: " + genLinks + " */");
            }
            String primitiveIDLType = IDL_XSDprimitive2IDLprimitive(genLinksBaseClass);
            output.OutputTextLine(depth, "typedef " + primitiveIDLType + " " + IDL_NormalizeUserDefinedClassifierName(classElem.Name) + ";");
            return;
        }

        /** Generate IDL4 module corresponding to the UML package
         *
         *  This function is the first-pass module generation. It generates the things that
         *  have no dependencies on anything else and help resolve dependencies for the types
         *  that depend on this module. These are:
         *
         *  enums
         *  typedefs for all structures defined in the module.
         *
         *  This function is recursive. It generates IDL for all the nested UML packages as well
         *
         *
         */
        private static void GenIDL_ModuleFirstPass(Repository repository, Package package, bool forceSelection,
            TextOutputInterface output, int depth, String pathToElem,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, HashSet<long> completedClasses)
        {
            // if unckecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if ( (!forceSelection) && IsElementUnchecked(uncheckedElem, packageFullName))
            {
                return;
            }

            if ( !IsModuleRelevant(relevantModules, package, output) )
            {
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Skipping empty module: \"" + package.Name + "\" */");
                }
                return;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);
            bool emptyModuleContent = true;
            output.OutputTextLine(depth, "module " + moduleName + " {");

            foreach (Element e in package.Elements)
            {
                if (IsElementUnchecked(uncheckedElem, packageFullName, e.Name))
                {
                    continue;
                }

                if (IsElementEnum(e))
                {
                    GenIDL_Enum(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                    if ( completedClasses != null ) {
                        completedClasses.Add(e.ElementID);
                    }
                    emptyModuleContent = false;
                }
                else
                {
                    if (GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, null))
                    {
                        GenIDL_ClassTypedef(e, output, depth + 1);
                        emptyModuleContent = false;
                    }
                }
            }

            foreach (Package p in package.Packages)
            {
                GenIDL_ModuleFirstPass(repository, p, false,
                    output, depth + 1, packageFullName, uncheckedElem, relevantModules, completedClasses);
                emptyModuleContent = false;
            }

            if (emptyModuleContent)
            {
                GenIDL_EmptyModuleContent(moduleName, output, depth + 1);
            }
            output.OutputTextLine(depth, "}; /* module " + moduleName + " */");
            output.OutputTextLine();
        }

        /** Generate IDL4 module corresponding to the UML package
         *
         *  This function is recursive. It generates IDL for all the nested UML packages and classes
         *
         * Returns the number of classes for which IDL could not be generated due to dependencies.
         *
         * The IDL for a class "C" can only be generated if we have already generated the IDL for all
         * the classes "C" depends on. This is determined by the return of the function:
         * GenIDL_DependenciesAlreadyGenerated()
         *
         * A return of "0" indicates there were no relevant classes for which the IDL could not be
         * generated. That is, the IDL generation is complete.
         *
         * A return >0 indicates IDL generation is not complete. In this case the GenIDL_ModuleSecondPass()
         * could be called again to generate additional classes that may have had their dependent
         * classes generated in the previous pass.
         *
         * If two successive calls to GenIDL_ModuleSecondPass() return the same value. That is, no progress
         * was made in on pass, this indicates there is a cyclic dependency that cannot be resolved.
         * In this case the strategy is to report the error so the user can break the dependency by, for example,
         * declaring on of the dependencies in the link as "@Shared"
         */
        private static int GenIDL_ModuleSecondPass(Repository repository, Package package, bool forceSelection,
            TextOutputInterface output, int depth, String pathToElem, out int generatedItemCount,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules,HashSet<long> completedClasses )
        {
            int notGeneratedClassCount = 0;
            generatedItemCount = 0;

            // if unckecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if ( (!forceSelection) && IsElementUnchecked(uncheckedElem, packageFullName) )
            {
                return 0;
            }

            if (!IsModuleRelevant(relevantModules, package, output))
            {
                return 0;
            }

            if (completedClasses.Contains(package.PackageID))
            {
                return 0;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);

            int moduleOutputPosition = output.GetCurrentPosition();
            output.OutputTextLine(depth, "module " + moduleName + " {");

            foreach (Element e in package.Elements)
            {
                // Skip Enum as they are generated on the first pass
                if ( !IsElementEnum(e) )
                {
                    if (GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, completedClasses))
                    {
                        if ( GenIDL_DependenciesAlreadyGenerated(repository, e, output, completedClasses, false) )
                        {
                            GenIDL_Class(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                            ++generatedItemCount;
                            completedClasses.Add(e.ElementID);
                        }
                        else
                        {
                            ++notGeneratedClassCount;
                        }
                    }
                }
            }

            foreach (Package p in package.Packages)
            {
                int subModuleGeneratedItemCount;
                int submoduleNonGenClassCount = GenIDL_ModuleSecondPass(repository, p, false,
                    output, depth + 1, packageFullName,
                    out subModuleGeneratedItemCount, uncheckedElem, relevantModules, completedClasses);
                notGeneratedClassCount += submoduleNonGenClassCount;
                generatedItemCount += subModuleGeneratedItemCount;

                if (submoduleNonGenClassCount == 0)
                {
                    // module is complete
                    completedClasses.Add(p.PackageID);
                }
            }

            if (generatedItemCount == 0)
            {
                GenIDL_EmptyModuleContent(moduleName, output, depth + 1);
                output.ClearPositionRange(moduleOutputPosition, output.GetCurrentPosition());
            }
            else
            {
                output.OutputTextLine(depth, "}; /* module " + moduleName + " */");
                output.OutputTextLine();
            }

            return notGeneratedClassCount;
        }


        /* Generate the IDL for an enum literal.
         */
        private static void GenIDL_EnumLiterals(Repository repository, String enumName, Element enumElem, TextOutputInterface output, int depth)
        {
            short childCount = enumElem.Attributes.Count;
            for (short i = 0 ; i < childCount; ++i )
            {
                EA.Attribute child = enumElem.Attributes.GetAt(i);
                // String typeName = IDL_NormalizeMemberTypeName(child.Type);

                // Handle enumeration values. The "default value set in UML takes precedence
                // if not then look at the tag Value
                int value;
                String valueAnnotation = null;
                if (Int32.TryParse(child.Default, out value))
                {
                    valueAnnotation = child.Default;
                    // output.OutputText(" //@Value " + child.Default);
                }
                else
                {
                    string[] relevantAnnotationsWithValue = new string[] {
                        "ID", "Value"
                    };

                    foreach (AttributeTag tag in child.TaggedValues)
                    {
                        String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);
                        if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                        {
                            valueAnnotation = tag.Value;
                        }
                    }
                }

                if ( (idlVersion >= IDLVersion.IDL_V400) && (valueAnnotation != null) )
                {
                    GenIDL_Annotation("Value", valueAnnotation, true, output, depth);
                }

                output.OutputText(depth, enumName + "_" + child.Name);

                if ((idlVersion == IDLVersion.IDL_V350_CONNEXT52) && (valueAnnotation != null))
                {
                    output.OutputText(" = " + valueAnnotation);
                }
                if (i < childCount - 1)
                {
                    output.OutputText(",");
                }

                if ((idlVersion == IDLVersion.IDL_V350_XTYPES) && (valueAnnotation != null))
                {
                    GenIDL_Annotation("Value", valueAnnotation, true, output, depth);
                }

                output.OutputTextLine();
            }
        }

        private static String GenIDL_GetFullPackageName(Repository repository, Element elem)
        {
            String packageName = "";
            int packageID = elem.PackageID;
            Package package = repository.GetPackageByID(packageID);
            int parentPackageID = package.ParentID;

            while (parentPackageID != 0)
            {
                packageName = IDL_NormalizeUserDefinedClassifierName(package.Name) + "::" + packageName;
                packageID = parentPackageID;
                package = repository.GetPackageByID(packageID);
                parentPackageID = package.ParentID;
            }

            return packageName;
        }

        /* Generate the IDL for an attribute.
         * The attribute can appear by itself, a sequence, or an array.
         * The determination of this is based on the settings of LowerBound and UpperBound
         *
         *    UpperBound == 0                 ==>  Unbounded Sequence
         *    LowerBound == UpperBound == 1        ==>  Single member (no Array/Sequence)
         *    LowerBound == 0 && UpperBound == 1   ==>  Optional single member
         *
         *    LowerBound  < UpperBound  (other values)    ==>  Bounded Sequence
         *    LowerBound == UpperBound  (other values)    == > Array
         *
         * returns true if it outputs some attribute; otherwise returns false
         */
        private static bool GenIDL_Attributes(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            if (classElem.Attributes.Count == 0)
            {
                return false;
            }

            foreach (EA.Attribute child in classElem.Attributes)
            {
                // This does not get the fully qualified type name. We need that to fully resolve
                // the type in the IDL...
                String typeName;

                /* This code was trying to get the fully-qualified name but it throws an exception
                 */
                if ( child.ClassifierID == 0 ) {
                    typeName = IDL_NormalizeMemberTypeName(child.Type);
                }
                else {
                    Element attributeType = repository.GetElementByID(child.ClassifierID);
                    Package attributePackage = repository.GetPackageByID(attributeType.PackageID);
                    typeName = GenIDL_GetFullPackageName(repository, attributeType)
                        + IDL_NormalizeMemberTypeName(attributeType.Name);
                }

                int lower  = 0;
                int upper  = 0;
                try {
                    lower = Convert.ToInt32(child.LowerBound);
                } catch (Exception) {}
                try {
                    upper = Convert.ToInt32(child.UpperBound);
                } catch (Exception) { }

                int attributeDepth = depth;

                String effectiveTypeName   = typeName;
                String effectiveMemberName = child.Name;
                String extraAnnotation = null;
                if (upper == 0) // Unbounded sequence
                {
                    //output.OutputText(attributeDepth, "sequence<" + typeName + "> " + child.Name + ";");
                    effectiveTypeName = "sequence<" + typeName + ">";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "// Mapping to unbounded sequence because (upper bound == 0)");
                    }

                }
                else if (lower == upper)
                {
                    if (upper != 1)  // Array
                    {
                        effectiveMemberName = child.Name + "[" + child.UpperBound + "]";
                        if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                        {
                            output.OutputTextLine(depth, "// Mapping to array because (lower bound == upper bound)");
                        }
                    }
                }
                else if (lower == 0 && upper == 1)
                {
                    // Handle this the same as an @optional annotation
                    extraAnnotation = "Optional";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "// Mapping to optional because (lower bound == 0 && upper bound == 1)");
                    }

                }
                else // bounded sequence
                {
                    effectiveTypeName = "sequence<" + typeName + "," + child.UpperBound + ">";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "// Mapping to bounded sequence because (lower bound < upper bound)");
                    }
                }

                GenIDL_AttributeWithAnnotations(child, effectiveTypeName, effectiveMemberName, extraAnnotation, output, depth);
                output.OutputTextLine();
            }

            return true;
        }

        private static void GenIDL_AttributeWithAnnotations(EA.Attribute child,
            String effectiveType, String effectiveName, String extraAnnotation,
            TextOutputInterface output, int depth)
        {
            int annotationCount = 0;
            if (idlVersion >= IDLVersion.IDL_V400)
            {
                annotationCount = GenIDL_AttributeAnnotations(child, output, depth);
                if (extraAnnotation != null)
                {
                    GenIDL_Annotation(extraAnnotation, annotationCount==0, output, depth);
                    ++annotationCount;
                }
            }
            output.OutputText(depth, effectiveType + " " + effectiveName + ";");

            if (idlVersion < IDLVersion.IDL_V400)
            {
                annotationCount = GenIDL_AttributeAnnotations(child, output, depth);
                if (extraAnnotation != null)
                {
                    GenIDL_Annotation(extraAnnotation, annotationCount==0, output, depth);
                    ++annotationCount;
                }
            }
        }

        /*
         * This outputs an annotation that has no paramaters
         */
        private static void GenIDL_Annotation(
            String annotationName, bool firstAnnotation,
            TextOutputInterface output, int depth)
        {
            GenIDL_Annotation(annotationName, null, firstAnnotation, output, depth);
        }


        /*
         * Maps annotations names and parameters from their normalized form to the
         * syntax specific to the version of IDL.
         *          * 
         */
        private static void GenIDL_MapAnnotation(
            String normalizedAnnotationName, String normalizedAnnotationParam1,
            out String mappedAnnotationName, out String mappedAnnotationParam1)
        {
            if ( (idlVersion == IDLVersion.IDL_V350_CONNEXT52 ) && normalizedAnnotationName.Equals("nested") )
            {
                mappedAnnotationName = "top-level";
                if ( (normalizedAnnotationParam1 == null ) || normalizedAnnotationParam1.ToLower().Equals("true") )
                {
                    mappedAnnotationParam1 = "FALSE";
                }
                else
                {
                    mappedAnnotationParam1 = "TRUE";
                }
            }
            else
            {
                mappedAnnotationName   = normalizedAnnotationName;
                mappedAnnotationParam1 = normalizedAnnotationParam1;
            }
        }

        /*
         * This outputs an annotation with zero or one paramater.
         * 
         * - annotationName. The normalized name of the annotation
         * 
         * - annotationParam1. The value of the annotation paramater. May be null if the
         *   annotation does not have any parameters
         *   
         * - firstAnnotation. Indicates whether this is the first annotation being generated for the class or
         *   the member. This affects the formatting for IDLVersion.IDL_V350_CONNEXT52
         */
        private static void GenIDL_Annotation(
            String annotationName, String annotationParam1, bool firstAnnotation,
            TextOutputInterface output, int depth)
        {
            // Depending on the version of IDL annotations need to be mapped
            String mappedAnnotationName;
            String mappedAnnotationParam1;
            GenIDL_MapAnnotation(annotationName, annotationParam1, out mappedAnnotationName, out mappedAnnotationParam1);

            if (idlVersion >= IDLVersion.IDL_V400)
            {
                output.OutputText(depth, "@" + mappedAnnotationName.ToLower());
                if ( (mappedAnnotationParam1 != null) && !mappedAnnotationParam1.Equals("") ) 
                {
                    output.OutputText("(" + mappedAnnotationParam1 + ") ");
                }
                //output.OutputTextLine();
            }
            else if (idlVersion >= IDLVersion.IDL_V350_XTYPES)
            {
                output.OutputText("  //@" + mappedAnnotationName);
                if ( (mappedAnnotationParam1 != null) && !mappedAnnotationParam1.Equals("") )
                {
                    output.OutputText("(" + mappedAnnotationParam1 + ") ");
                }
            }
            else // IDLVersion.IDL_V350_CONNEXT52
            {
                if (firstAnnotation)
                {
                    output.OutputText("  //@" + mappedAnnotationName);
                }
                else {
                    // output.OutputTextLine();
                    output.OutputText(depth, "    //@" + mappedAnnotationName);
                }

                if ( (mappedAnnotationParam1 != null) && !mappedAnnotationParam1.Equals("") )
                {
                    output.OutputText(" " + mappedAnnotationParam1);
                }
            }
        }

        /** Outputs the annotations associated with the attribute
         *
         * Returns the number of annotations printed
         */
        private static int GenIDL_AttributeAnnotations(EA.Attribute child, TextOutputInterface output, int depth)
        {
            string keyAnnotation = "Key";
            string[] relevantAnnotationsNoValue = new string[] {
                    keyAnnotation,
                    "must_understand",
                    "autoid", "Optional",
                    "external",
                    "oneway", "ami"
                };
            string[] relevantAnnotationsWithValue = new string[] {
                    "ID", "Value"
                };

            string ddsTag = "DDS";

            Boolean mappedToKey = false;
            int annotationCount = 0;

            foreach (AttributeTag tag in child.TaggedValues)
            {
                String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);

                // Accept the TagName DDS as an alternative way to provide an accepted no value annotation
                // So {Tag, Value} = {"DDS", "XYZ"} is equivalent to {"XYZ", }
                if (normalizedAnnotation.Equals(ddsTag))
                {
                    normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Value);
                }

                if (relevantAnnotationsNoValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, annotationCount==0, output, depth);
                    ++annotationCount;
                    if ( normalizedAnnotation.Equals(keyAnnotation) ) {
                        mappedToKey = true;
                    }
                }
                else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, tag.Value, annotationCount == 0, output, depth);
                    ++annotationCount;
                }
                else
                {
                    if ((idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL))
                    {
                        output.OutputTextLine(depth, "/* Skipping unknown annotation name: \"" + tag.Name + "\" value: \"" + tag.Value + "\" */");
                    }
                }
            }

            // Accept the attributes marked as ID as being "Key"
            if ( (!mappedToKey) && child.IsID )
            {
                mappedToKey = true;
                GenIDL_Annotation(keyAnnotation, annotationCount == 0, output, depth);
                ++annotationCount;
                if ((idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL))
                {
                    output.OutputTextLine(depth, "/* Mapping to @Key because attribute has the IsID property set */");
                }
            }


            return annotationCount;
        }

        /*
         * Determinies member name used when a member is created as a result of a reference to some other class/element
         * The member name is chosen following a set of rules to it is the "most natural one" accoding to whether the user
         * has explicitly named the role, reference, etc.
         * The criteria is:
         *   - Use the rolename if present
         *   - Else use the relationship name
         *   - Else use the name of the target class starting with lower case, or preceeded with a "m_"
         *   
         * Names are always normalized to prevent using characters that would be invalid as a member name
         * When the classname is used a "numeric suffix" is used to prevent multiple references to the same
         * class resulting on member name collisions
         */
        private static String GenIDL_GetReferenceName(EA.Connector conn, EA.ConnectorEnd referencedElemEnd, EA.Element referencedElem)
        {
            String refName = referencedElemEnd.Role;
            if ( refName.Equals("") )  {
                refName = conn.Name;
            }
            if (refName.Equals(""))    {
                char firstLetter = referencedElem.Name[0];
                if ( char.IsUpper(firstLetter) )  {
                    refName = char.ToLower(firstLetter) + referencedElem.Name.Substring(1);
                }
                else {
                    refName = "m_" + referencedElem.Name;
                }
            }

            return IDL_NormalizeUserDefinedClassifierName(refName);
        }

        /*
         * Returns a description of the reference relationship along with a decision on
         * whether the referenced element should appear as a member of the source element.
         * 
         * Background on UML Associations:
         * http://www.uml-diagrams.org/association.html
         * 
         * To appear as a member the relationship must:
         * - Be "Association", "Aggregation", or "Nesting"
         * - Be navigable to the referenced element
         * - Have (source) aggregation property of "shared" or "composite"
         * - We do not look at the TARGET role containment. It does not matter if it is 
         *   value, reference, or unspecified
         *                                                                       referencedElem
         *    +-------------------+  sourceElemEnd       referencedElemEnd  +-----------------+
         *    |  sourceElementId  | ----------------------------------------| targetElementId |
         *    +-------------------+               conn                      +-----------------+
         *    
         *                                 memberName (computed from relationship name)
         *                                 
         * The funtion fills the output paramaters as follows:
         * 
         * - includeInSourceElem. Set to TRUE if the target class should be included as 
         *   a member of the source class. If it is set to FALSE the member will not appear and
         *   the explantion out parameter will be filled.
         *   
         * - explanation. Contains the explanation of why tha target class is not included
         *   as a member of the source class. Filled if and only if includeInSourceElem = FALSE
         *   and explain = TRUE.
         *   
         * - sourceElemEnd. The connectorId corresponding to the sourceElemId. Note that in the
         *   UMM model it could be either the SOURCE or TARGET connector. But this function
         *   normalized it so it it seen from the perspectibe of the sourceElemId. 
         *   
         * - referencedElemId. The ElementId of the element at the other side of the relationship
         *   from the point of view of the sourceElemId.
         *  
         * - memberName. The name of the member that would be generated. This is filled even if
         *   the relationship does not cause a member to be generated, that way the member name
         *   can be used in the log messages.
         * 
         * - referencedElem. The Element corresponding to the referencedElemId. If 
         *   includeInSourceElem = TRUE, then the referenced element will be a valid element in 
         *   the repository as this is checked as a condition for includeInSourceElem=TRUE.
         */
        private static void GenIDL_ReferenceDescriptor(
            EA.Repository repository, EA.Connector conn, int sourceElemId, bool explain,
            out EA.ConnectorEnd sourceElemEnd, out EA.ConnectorEnd referencedElemEnd, 
            out int referencedElemId, out EA.Element referencedElem,
            out String memberName, out bool includeAsReference,
            out bool includeInSourceElem, out String explanation)
        {
            includeInSourceElem = false;
            explanation = null;
            memberName = null;
            includeAsReference = false;

            /* Normalize the relationship identofyign the source and target roles */
            if (sourceElemId == conn.ClientID)
            {
                sourceElemEnd = conn.ClientEnd;
                referencedElemEnd = conn.SupplierEnd;
                referencedElemId = conn.SupplierID;
            }
            else
            {
                sourceElemEnd = conn.SupplierEnd;
                referencedElemEnd = conn.ClientEnd;
                referencedElemId = conn.ClientID;
            }

            referencedElem = repository.GetElementByID(referencedElemId);
            if (referencedElem == null)
            {
                if (explain)
                {
                    explanation = "target element with ElementID = " + referencedElemId + " is not found in UML Repository";
                }
                return;
            }

            memberName = GenIDL_GetReferenceName(conn, referencedElemEnd, referencedElem);

            // Only consider "Aggregation", "Association", and "Nesting" relationships as reasons to include the
            // referenced element as a member
            string[] relevantConnectorTypes = new string[] { "Association", "Aggregation", "Nesting" };
            if (!relevantConnectorTypes.Contains(conn.Type))
            {
                if (explain)
                {
                    explanation = "association type is '" + conn.Type + "' instead of 'Association', 'Aggregation', or 'Nesting'";
                }
                return;
            }

            if (referencedElemEnd.IsNavigable == false)
            {
                if (explain)
                {
                    explanation = "target role Navigability property is false";
                }
                return;
            }

            if (sourceElemEnd.Aggregation == 0)
            {
                if (explain)
                {
                    explanation = "source role Aggegation property is 'none' instead of 'shared' or 'composite'";
                }
                return;
            }

            /*
            if (conn.Type.Equals("Association") && !referencedElemEnd.Containment.Equals("Value"))
            {
                if (explain)
                {
                    explanation = "target role containment type is '"  + referencedElemEnd.Containment + "' instead of 'Value'";
                }
                return;
            }
            */

            // Determine if the referenced element is "by value" or "by reference"
            // sourceElemEnd.Aggregation can be 0, 1, 2 for  none, shared, composite. See http://www.sparxsystems.com/enterprise_architect_user_guide/12.1/automation_and_scripting/connectorend.html

            // Note that we alredy know that sourceElemEnd.Aggregation != 0. Otherwise we are not generating the member
            if ((referencedElemEnd.Containment.Equals("Reference"))
                 || (referencedElemEnd.Containment.Equals("Unspecified") && sourceElemEnd.Aggregation == 1 ))
            {
                includeAsReference = true;
            }
            else // in this case either Containment.Equals("Reference") or sourceElemEnd.Aggregation == 2
            {
                includeAsReference = false;
            }

            includeInSourceElem = true;
            return;
        }

        /**
         * Given a class (sourceClass) that is being mapped to IDL, this function is invoked on each reference (connector). 
         * that the sourceClass has to determine if the reference/connector should result on a member being added to sourceClass.
         * 
         * The function returns the fully qualified (and normalized) name for the type referenced by the connector in case 
         * the referenced type needs to be included as a member of the "sourceClass". If there is no member to be included as
         * a result of the reference/connector the function returns the null string.
         * 
         * In addition to the name of the referenced element the function returns the annotations that the member should have.
         *
         * Paramaters:
         * - sourceClass. This is the class that is being mapped to IDL
         * - conn. A connector for sourceClass
         * - (out) memberName. The member being generated. 
         *   type if the multiplicity of the relationship requires that.
         * - (out) annotations. The annotations on the member.
         * - (return value) the memberType for memberName. The memberType includes fully-scoped typenames
         *   as well as any needed sequences 
         */
        private static String GenIDL_GetReferencedTypeToInclude(
            out List<String> annotations, out String memberName,
            Repository repository,
            Element sourceClass, EA.Connector conn, TextOutputInterface output, int depth)
        {
            annotations   = null;
            memberName    = null;

            // Generalization (Inheritance) does not cause the referenced element to 
            // appear as member. This is well understood so no need to report more details on why
            if (conn.Type.Equals("Generalization"))
            {
                return null;
            }

            Element referencedElem;
            ConnectorEnd thisElemEnd;
            ConnectorEnd referencedElemEnd;
            int referencedElemId;
            String explanation;
            bool includeReferencedTypeAsMember;
            bool includeAsReference;

            bool reportExplanationText = idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_BASIC;

            // This resolves the details of the reference and determines whether a member should be
            // generated of not.
            GenIDL_ReferenceDescriptor(repository, conn, sourceClass.ElementID, reportExplanationText,
                out thisElemEnd, out referencedElemEnd, out referencedElemId, out referencedElem, 
                out memberName, out includeAsReference,
                out includeReferencedTypeAsMember, out explanation);

            if ( !includeReferencedTypeAsMember ) {
                if ( reportExplanationText ) {
                    String referencedElementClassName = "Unknown Type";
                    if (referencedElem != null)
                    {
                        referencedElementClassName = referencedElem.Name;
                    }

                    output.OutputTextLine(depth, "/* Skipping reference \"" + memberName
                        + "\" to element \"" + referencedElementClassName + "\" because " + explanation + " */");
                }
                return null;
            }

            /* If we are here we know includeReferencedTypeAsMember == TRUE
             * this means referenced class as a member of this element 
             * and also that referencedElem != null as this is checked by GenIDL_ReferenceDescriptor() */
            String memberTypeScoped = null;
            String cardinality = referencedElemEnd.Cardinality;
           

            String normalizedMemberType = IDL_NormalizeMemberTypeName(referencedElem.Name);
            memberTypeScoped = GenIDL_GetFullPackageName(repository, referencedElem) + normalizedMemberType;

            // Apply cardinality rules. Can cause member to be @Optional, or a sequence
            if (cardinality.Equals("0..1"))
            {
                // Zero or one -> Optional
                if (annotations == null )
                {
                    annotations = new List<String>();
                }
                annotations.Add("@Optional");
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to Optional because relation cardinality == \"0..1\" */");
                }
            }
            else if (cardinality.Equals("*") || cardinality.EndsWith("..*") || cardinality.EndsWith(".."))
            {
                // No upper limit -> unbounded sequence
                memberTypeScoped = "sequence<" + memberTypeScoped + ">";
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to unbounded sequence because relation cardinality is \"*\", \"..*\", or \"..\" */");
                }
            }
            else if (cardinality.Equals("") || cardinality.Equals("1") || cardinality.Equals("0"))
            {
                // Map to regular member. No sequence, no optional
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to regular member because relation cardinality is \"\", \"1\", or \"0\" */");
                }
            }
            else
            {
                // Bounded sequence
                int upperLimit = 0;
                if (Int32.TryParse(cardinality, out upperLimit))
                {
                    if (upperLimit <= 0) { upperLimit = 1; }
                    memberTypeScoped = "sequence<" + memberTypeScoped + "," + upperLimit + ">";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "/* Mapping to bounded sequence because relationship cardinality = "
                                                    + cardinality + " (lower bound < upper bound) */");
                    }
                }
                else
                {
                    int limitPos = cardinality.LastIndexOf("..");
                    if ((limitPos != -1) &&
                            Int32.TryParse(cardinality.Substring(limitPos + 2), out upperLimit))
                    {
                        memberTypeScoped = "sequence<" + memberTypeScoped + "," + upperLimit + ">";
                        if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                        {
                            output.OutputTextLine(depth, "/* Mapping to bounded sequence because relationship cardinality = "
                                                        + cardinality + " (lower bound < upper bound) */");
                        }
                    }
                    else
                    {
                        memberTypeScoped = "sequence<" + memberTypeScoped + ">";
                        if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                        {
                            output.OutputTextLine(depth, "/* Mapping to unbounded sequence because relationship cardinality = "
                                                        + cardinality + " */");
                        }
                    }
                }

            }

            // Members included by reference are mapped to the @Shared annotation 
            if (includeAsReference)
            {
                if (idlVersion == IDLVersion.IDL_V350_CONNEXT52)
                {
                    memberTypeScoped = memberTypeScoped + "*";
                }
                else // Otherwise use an annotation
                {
                    if (annotations == null)
                    {
                        annotations = new List<String>();
                    }
                    annotations.Add("@Shared");
                }
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to Shared because Containment is 'Reference' or Aggregation is 'Shared' */");
                }
            }

            return memberTypeScoped;
        }

        //TODO: This should examine the relationship and determine the multiplicity so that
        //      the relationship can be generated as a sequence rather than single reference.
        private static bool GenIDL_Relations(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            bool generatedRelationship = false;

            foreach (EA.Connector conn in classElem.Connectors)
            {
                List<String> annotations = null;
                String refname = null;
                String referencedType = GenIDL_GetReferencedTypeToInclude(out annotations, out refname, repository, classElem, conn, output, depth);

                if (referencedType != null)
                {
                    if (annotations != null)
                    {
                        if (idlVersion >= IDLVersion.IDL_V400)
                        {
                            output.OutputText(depth, annotations[0] + " ");
                            for (int i = 1; i < annotations.Count; ++i)
                            {
                                output.OutputText(annotations[i] + " ");
                            }
                            output.OutputTextLine(referencedType + "  " + refname + "; ");
                        }
                        else
                        {
                            output.OutputTextLine(depth, referencedType + "  " + refname + "; //" + annotations[0]);
                            for (int i=1; i< annotations.Count; ++i)
                            { 
                                output.OutputTextLine(depth, "//" + annotations[i]);
                            }
                        }
                    }
                    else
                    {
                        output.OutputTextLine(depth, referencedType + "  " + refname + ";");
                    }
                    generatedRelationship = true;
                }
            }

            return generatedRelationship;
        }

        private static String IDL_FullElementName(String elementPath, String elementName)
        {
            return elementPath + "\\" + elementName;
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementFullName)
        {
            return (uncheckedElem != null) && (uncheckedElem.Contains(elementFullName));
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementPath, String elementName)
        {
            if (uncheckedElem == null)
            {
                return false;
            }
            return uncheckedElem.Contains(IDL_FullElementName(elementPath, elementName));
        }

        private static bool IsElementEnum(Element elem)
        {
            return elem.Type.Equals("Enumeration") || elem.Stereotype.Equals("enumeration");
        }

        /**
         *  This function traverses the package, recursively visiting all its children, and updates
         *  the moduleRelevance dictionary storing whether each individual module is relevant or not
         *
         * Relevance is currently defined as not being empty for the purposes of IDL generation. This
         * means having some class, some enumeration, or recursively containing a relevant sub-package
         */
        private static bool UpdateModuleRelevance(Dictionary<long, bool> moduleRelevance, Package package,
            TextOutputInterface output)
        {
            bool relevantModule = false;

            foreach (Package p in package.Packages)
            {
                relevantModule = UpdateModuleRelevance(moduleRelevance, p, output) || relevantModule;
            }

            if (relevantModule == false)
            {
                foreach (Element e in package.Elements)
                {
                    if (IsElementEnum(e) || IsClass(e))
                    {
                        relevantModule = true;
                        break;
                    }
                }
            }
            moduleRelevance.Add(package.PackageID, relevantModule);

            return relevantModule;
        }

        private static bool IsModuleRelevant(Dictionary<long, bool> moduleRelevance, Package package, TextOutputInterface output)
        {
            bool isRelevant = true;
            if (!moduleRelevance.TryGetValue(package.PackageID, out isRelevant))
            {
                output.OutputTextLine("IsModuleRelevant; Error did not find: " + package.Name);
                return true;
            }
            return isRelevant;
        }

        private static void GenIDL_Enum(Repository repository, Element enumElem,
             TextOutputInterface output, int depth,
             HashSet<String> uncheckedElem, String elementPath)
        {
            String enumNameNormalized = IDL_NormalizeUserDefinedClassifierName(enumElem.Name);
            output.OutputTextLine(depth,
                "enum " + enumNameNormalized + " {");

            //output.OutputTextLine(depth, "/* elementID = " + enumElem.ElementID + " */");
            GenIDL_EnumLiterals(repository, enumNameNormalized, enumElem, output, depth + 1);
            output.OutputTextLine(depth, "};");
        }

        private static bool GenIDL_MustGenerateClass(Repository repository, Element classElem,
             String elementPath, HashSet<String> uncheckedElem, HashSet<long> completedClasses)
        {
            // Check that it is a class
            if (!IsClass(classElem))
            {
                return false;
            }

            // If already generated skip class
            if ( (completedClasses != null) && completedClasses.Contains(classElem.ElementID) )
            {
                return false;
            }

            // If unchecked, skip class
            if (IsElementUnchecked(uncheckedElem, elementPath, classElem.Name))
            {
                return false;
            }

            return true;
        }

        private static void GenIDL_EmptyClassContent(String className,
            TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "octet __dummy_prevent_empty_class_" + IDL_NormalizeUserDefinedClassifierName(className) + ";");
        }

        private static void GenIDL_EmptyModuleContent(String moduleName,
            TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "const long EmptyModule_Sentinel_" + moduleName + " = 0;");
        }

        /**
         * Checks that all the definitions this class depends on are already generated
         * This includes the base classes as well as any types that appear as
         * attributes and are not marked "@Shared"
         *
         */
        private static bool GenIDL_DependenciesAlreadyGenerated(Repository repository, Element classElem,
            TextOutputInterface output, HashSet<long> completedClasses, bool outputReport)
        {

            //output.OutputTextLine("// GenIDL_DependenciesAlreadyGenerated Checking: " + classElem.Name);

            // Check base classes
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                if (!completedClasses.Contains(elem.ElementID))
                {
                    if (outputReport)
                    {
                        output.OutputText("    ( \"" + GenIDL_GetFullPackageName(repository, classElem) + "\" , \"" + classElem.Name + "\" )");
                        output.OutputText("  depends on  ( " + GenIDL_GetFullPackageName(repository, elem) + "\" , \"" + elem.Name + "\" )");
                        output.OutputTextLine("  dependency: baseclass");
                    }
                    return false;
                }
            }

            // Check atributes
            foreach (EA.Attribute child in classElem.Attributes)
            {
               if (child.ClassifierID == 0) /* Primitive type */
                {
                    continue;
                }
                if (!completedClasses.Contains(child.ClassifierID))
                {
                    // Not generated yet. It is only OK if this is by reference
                    if ( !IsAttributeReference(child) )
                    {
                        if (outputReport)
                        {
                            Element childTypeElem = repository.GetElementByID(child.ClassifierID);
                            output.OutputText("    ( \"" + GenIDL_GetFullPackageName(repository, classElem) + "\" , \"" + classElem.Name + "\" )");
                            output.OutputText("  depends on  ( " + GenIDL_GetFullPackageName(repository, childTypeElem) + "\" , \"" + childTypeElem.Name + "\" )");
                            output.OutputTextLine("   dependency:  attribute \"" + child.Name + "\"");
                        }

                        return false;
                    }
                }
            }

            // Check relationships (Aggregations only)
            String explanation;
            foreach (EA.Connector conn in classElem.Connectors)
            {
                ConnectorEnd thisElemEnd;
                ConnectorEnd referencedElemEnd;
                int referencedElemId;
                Element referencedElem;
                bool includeReferencedTypeAsMember;
                String memberName;
                bool includeAsReference;

                // Resolve the reference but ommit any explanatory text
                GenIDL_ReferenceDescriptor(repository, conn, classElem.ElementID, false,
                                            out thisElemEnd, out referencedElemEnd, out referencedElemId, out referencedElem,
                                            out memberName, out includeAsReference,
                                            out includeReferencedTypeAsMember, out explanation);

                // If the reference did not have to be included, there there is no dependency on it.
                if ( includeReferencedTypeAsMember == false ) {
                    continue;
                }

                // If we are here then the referenced element must appear as a member. There is a depedency so we must make sure
                // that that class has already been generated
                if (!completedClasses.Contains(referencedElemId))
                {
                    if (outputReport)
                    {
                        output.OutputText("    ( \"" + GenIDL_GetFullPackageName(repository, classElem) + "\" , \"" + classElem.Name + "\" )");
                        output.OutputText("  depends on  ( " + GenIDL_GetFullPackageName(repository, referencedElem) + "\" , \"" + referencedElem.Name + "\" )");
                        output.OutputTextLine("   dependency:  aggregation \"" + memberName + "\"");
                    }

                    return false;
                }
            }

            return true;
        }

        /**
         *  Determines whether the attribute links the member by reference
         *  indicating that the type of the attribute does not need to be fully declared by
         *  the time we generate the IDL for the containing class.
         *
         *  This is true for attributes tagged "@Shared" and maybe others as well
         */
        private static bool IsAttributeReference(EA.Attribute member)
        {
            return (member.TaggedValues != null) && (EAUtil_FindChild(member.TaggedValues, "//@Shared") != null);
        }

        private static void GenIDL_Class(Repository repository, Element classElem,
            TextOutputInterface output, int depth,
            HashSet<String> uncheckedElem, String elementPath)
        {
            // Check if this was a XSD simpleType if so there is nothing to do because we already generated
            // a typedef for it...
            if (IsXSDSimpleType(classElem))
            {
                return;
            }

            String className = IDL_NormalizeUserDefinedClassifierName(classElem.Name);
            String baseClassName = null;
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                baseClassName = GenIDL_GetFullPackageName(repository, elem)
                    + IDL_NormalizeUserDefinedClassifierName(elem.Name);

                if (baseClassName == null)
                {
                    output.OutputText(depth, "/* Warning: empty base class ommitted for " + classElem.Name + "*/");
                }
            }



            // In IDL4 and higher annotations are before the class
            if  (idlVersion >= IDLVersion.IDL_V400) {
                GenIDL_ClassAnnotation(classElem, output, depth);
            }
            output.OutputText(depth, "struct " + className);

            if (baseClassName != null)
            {
                output.OutputText(" : " + baseClassName);
            }
            output.OutputTextLine(" {");

            bool emptyClassContent = true;
            if (GenIDL_Attributes(repository, classElem, output, depth + 1))
            {
                emptyClassContent = false;
            }
            if (GenIDL_Relations(repository, classElem, output, depth + 1))
            {
                emptyClassContent = false;
            }

            if (emptyClassContent)
            {
                GenIDL_EmptyClassContent(className, output, depth + 1);
            }
            output.OutputText(depth, "};");

            // In IDL35 annotations may appear after the class as a comment
            if (idlVersion < IDLVersion.IDL_V400)
            {
                GenIDL_ClassAnnotation(classElem, output, depth);
            }
            output.OutputTextLine();
        }

        private static int GenIDL_ClassAnnotation(Element classElem,
            TextOutputInterface output, int depth)
        {
            string[] relevantAnnotationsNoValue = new string[] {
                "autoid",
                "final", "mutable", "extensible",
                "service"
            };
            string[] relevantAnnotationsWithValue = new string[] {
                "Extensibility", "verbatim", "nested"
            };

            string ddsTag = "DDS";

            int annotationCount = 0;
            foreach (TaggedValue tag in classElem.TaggedValues)
            {
                String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);

                // Accept the TagName DDS as an alternative way to provide an accepted no value annotation
                // So {Tag, Value} = {"DDS", "XYZ"} is equivalent to {"XYZ", }
                if (normalizedAnnotation.Equals(ddsTag))
                {
                    normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Value);
                }

                if (relevantAnnotationsNoValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, annotationCount == 0, output, depth);
                    output.OutputTextLine();
                    ++annotationCount;
                }
                else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, tag.Value, annotationCount == 0, output, depth);
                    output.OutputTextLine();
                    ++annotationCount;
                }
                else
                {
                    if ((idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL))
                    {
                        output.OutputTextLine(depth, "/* Skipping unknown annotation name:\"" + tag.Name + "\" value: \"" + tag.Value + "\" */");
                    }
                }
            }

            return annotationCount;
        }


        private static char[] invalidTypenameChars = new char[] { ' ', '-', '&', '(', ')' };

        /**  Normalizes a user-defined UML classifier (class / package) name into a legal IDL class/module name
         *
         */
        public static String IDL_NormalizeUserDefinedClassifierName(String classifierName)
        {
            for (int index = 0; index < invalidTypenameChars.GetLength(0); ++index) {
                classifierName = classifierName.Replace(invalidTypenameChars[index], '_');
            }

            return classifierName;
        }

        private static readonly string[] boolTypes      = new string[] { "boolean", "bool" };
        private static readonly string[] charTypes      = new string[] { "char" };
        private static readonly string[] wcharTypes     = new string[] { "wchar", "wchar_t" };

        private static readonly string[] longlongTypes  = new string[] { "long long", "int64", "int64_t" };
        private static readonly string[] ulonglongTypes = new string[] { "unsigned long long", "uint64", "uint64_t" };
        private static readonly string[] longTypes      = new string[] { "long", "int", "int32", "int32_t", "integer", "decimal", "unlimitednatural"};
        private static readonly string[] ulongTypes     = new string[] { "unsigned long", "unsigned int", "ulong", "uint", "uint32", "uint32_t" };
        private static readonly string[] shortTypes     = new string[] { "short", "int16", "int16_t" };
        private static readonly string[] ushortTypes    = new string[] { "unsigned short", "ushort", "uint16", "uint16_t" };
        private static readonly string[] octetTypes     = new string[] { "octet", "byte", "sbyte", "int8", "int8_t", "uint8", "uint8_t" };
        private static readonly string[] floatTypes     = new string[] { "float", "float32", "number", "real" };
        private static readonly string[] doubleTypes    = new string[] { "double", "float64" };
        private static readonly string[] stringTypes    = new string[] { "string", "String" };
        private static readonly string[] wstringTypes   = new string[] { "wstring" };

        private static readonly string[][] primtiveTypeVariations = {
            boolTypes, charTypes, wcharTypes, 
            longlongTypes, ulonglongTypes, longTypes, ulongTypes, shortTypes, ushortTypes, octetTypes, floatTypes, doubleTypes, 
            stringTypes,  wstringTypes };

        private static readonly Regex MultipleSpaces = new Regex(@" {2,}", RegexOptions.Compiled);

        /** Normalizes a type name converting it into a legal IDL4  type.
         *
         * This function handles common variations of primitive type names. For anything non-primitive
         * it just calls IDL_NormalizeUserDefinedClassifierName
         */
        private static String IDL_NormalizeMemberTypeName(String typeName)
        {
            String normalizedType = MultipleSpaces.Replace(typeName, " ");
            for (int typeFamily = 0; typeFamily < primtiveTypeVariations.GetLength(0); ++typeFamily)
            {
                if (primtiveTypeVariations[typeFamily].Contains(normalizedType.ToLower()))
                {
                    return primtiveTypeVariations[typeFamily][0];
                }
            }

            return IDL_NormalizeUserDefinedClassifierName(normalizedType);
        }


        private static readonly string[] keyAnnotation = new string[] { "Key", "key" };
        private static readonly string[] mustUnderstandAnnotation = new string[] { "must_understand" };

        private static readonly string[] idAnnotation = new string[] { "ID", "id" };
        private static readonly string[] autoidAnnotation = new string[] { "autoid" };
        private static readonly string[] optionalAnnotation = new string[] { "Optional", "optional" };
        private static readonly string[] valueAnnotation = new string[] { "value" };

        private static readonly string[] extensibilityAnnotation = new string[] { "Extensibility", "extensibility" };
        private static readonly string[] finalAnnotation = new string[] { "final" };
        private static readonly string[] mutableAnnotation = new string[] { "mutable" };

        private static readonly string[] defaultAnnotation = new string[] { "default" };
        private static readonly string[] rangeAnnotation = new string[] { "range" };
        private static readonly string[] minAnnotation = new string[] { "min" };
        private static readonly string[] maxAnnotation = new string[] { "max" };
        private static readonly string[] unitAnnotation = new string[] { "unit" };

        private static readonly string[] bitBoundAnnotation = new string[] { "bit_bound" };
        private static readonly string[] externalAnnotation = new string[] { "external" };
        private static readonly string[] nestedAnnotation = new string[] { "nested" };

        private static readonly string[] verbatimAnnotation = new string[] { "verbatim" };

        private static readonly string[] serviceAnnotation = new string[] { "service" };
        private static readonly string[] onewayAnnotation = new string[] { "oneway" };
        private static readonly string[] amiAnnotation = new string[]   { "ami" };

        // Not strictly a IDL3.5, 4, or XTYPES annotation but something users do sometimes
        private static readonly string[] ddsAnnotation = new string[] { "DDS", "dds" };

        private static readonly string[][] builtinAnnotationVariations = {
            keyAnnotation, mustUnderstandAnnotation,
            idAnnotation, autoidAnnotation, optionalAnnotation, valueAnnotation,
            extensibilityAnnotation, finalAnnotation, mutableAnnotation,
            defaultAnnotation, rangeAnnotation, minAnnotation, maxAnnotation, unitAnnotation,
            bitBoundAnnotation, externalAnnotation, nestedAnnotation,
            verbatimAnnotation,
            serviceAnnotation, onewayAnnotation, amiAnnotation,
            ddsAnnotation
        };

        /** Normalizes an annotation type name converting it into a legal IDL4 / Connext DDS annotation.
         *
         * This function handles common variations of capitalization for the builtin annotations. For anything
         * non-built-in it just leaves it unchanged
         */
        private static String IDL_NormalizeAnnotationName(String annotationName)
        {
            String annotationNameLower = annotationName.ToLower();
            for (int annotationType = 0; annotationType < builtinAnnotationVariations.GetLength(0); ++annotationType)
            {
                if ( builtinAnnotationVariations[annotationType].Contains(annotationNameLower) )
                {
                    return builtinAnnotationVariations[annotationType][0];
                }
            }

            return annotationName;
        }

        /**
         * Determines whether this is a model element relevant to Connext DDS and we need to
         * generate code associated with the model element.
         */
        private static bool IsClass(Element e)
        {
            return (e.Type == "Class");
        }

        private static bool IsEmptyClass(Element e)
        {
            return (e.Attributes.Count == 0) && (e.Connectors.Count == 0);
        }


        internal static void setIdlVersion(int p)
        {
            Main.idlVersion = p;
        }

        internal static void setIdlMappingDetail(int p)
        {
            Main.idlMappingDetail = p;
        }

    }
}

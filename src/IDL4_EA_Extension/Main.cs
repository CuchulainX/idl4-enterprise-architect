/*********************************************************************************************
Copyright 2015 Real-Time Innovations, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
**********************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;


/* For the Sparx Automation APIs see:
 * http://bellekens.com/2011/01/29/tutorial-create-your-first-c-enterprise-architect-addin-in-10-minutes/
 * https://alexatnet.com/articles/creating-addin-for-sparx-enterprise-architect
 * http://blog.sparxsystems.eu/2015/05/the-enterprise-architect-object-model-ea-api/
 * http://bellekens.com/writing-ea-add-ins/
 */

using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using EA;

namespace IDL4_EA_Extension
{
    public class IDLGenAction : UserActionInterface
    {
        private EA.Repository _currentRepository = null;
        private TextOutputInterface _currentOutput = null;
        private HashSet<string> _uncheckedElements = null;
        private IDLClassSelector _classSelector = null;

        public void Initialize(EA.Repository repository, TextOutputInterface output, IDLClassSelector classSelector,
            HashSet<string> uncheckedElements)
        {
            _currentRepository = repository;
            _currentOutput = output;
            _uncheckedElements = uncheckedElements;
            _classSelector = classSelector;
            this.OnIdlVersionAction(IDLVersions.defaultVersion);
            this.OnIdlMappingDetailAction(IDLVersions.defaultMappingDetails);
        }

        public void OnCodegenAction()
        {
            Main.GenIDL(_currentRepository, false, _currentOutput, _uncheckedElements);
        }

        public void OnSaveAction(string filePath)
        {
            String[] preambleLines = {
               "/*",
               " *  IDL file generated by RTI Connext DDS Enterprise Architect IDL 4 Add-in version 1.0",
               " *      Enterprise Architect File:  " + _currentRepository.ConnectionString,
               " *      Date: " + DateTime.Now.ToString(),
               " */",
               " "
            };

            _currentOutput.SaveToFile(filePath, preambleLines);
        }

        public void OnSelectAction(TreeNode treeNode)
        {
            OnDebugAction("Selected Node: " + treeNode.FullPath);
            Main.GenIDL_Preview(_currentRepository, _currentOutput, _uncheckedElements, treeNode.FullPath);
        }

        public void OnCheckAction(TreeNode treeNode)
        {
            // Remember whether it is uncheked or not
            if (treeNode.Checked)
            {
                _uncheckedElements.Remove(treeNode.FullPath);
            }
            else
            {
                _uncheckedElements.Add(treeNode.FullPath);
            }
        }

        public void OnIdlVersionAction( IDLVersion ver )
        {
            _currentOutput.Clear();

            Main.setIdlVersion(ver.Value);
        }

        public void OnIdlMappingDetailAction(IDLMappingDetail detail)
        {
            _currentOutput.Clear();

            Main.setIdlMappingDetail(detail.Value);
        }

        public void OnDebugAction(string text)
        {
            _currentOutput.OutputTextLine(text);
        }
    }

    /* This is a helper class to resolve a connector from the perspective of one of the
     * two elements that terminate the connector.
     * It resolves
     * - The referenced elementID
     * - The two connectors ends. "source" and "refernced element" 
     */
    class ReferenceDescriptor
    {
        public ReferenceDescriptor()
        {
            sourceElemEnd     = null;
            referencedElemEnd = null;
            referencedElemId  = 0;
            shouldBeIncludedInSourceElemClass = false;
            explanation       = null;
        }
        public ConnectorEnd  sourceElemEnd;
        public ConnectorEnd  referencedElemEnd;
        public int           referencedElemId;
        public bool          shouldBeIncludedInSourceElemClass;
        String               explanation;
    };

    [ComVisible(true)]
    public class Main
    {

        private const String IDL_GENERATOR_REVISION = "1.6";
        private const String MENU_ROOT_RTI_CONNEXT  = "- IDL4  (RTI Connext DDS)";
        private const String MENU_ITEM_GENERATE_IDL = "Generate IDL ...";

        private static int idlVersion = IDLVersions.defaultVersion.Value;
        private static int idlMappingDetail = IDLVersions.defaultMappingDetails.Value;



        // Called Before EA starts to check Add-In Exists
        public string EA_Connect(Repository repository)
        {
            // nothing special
            return "EaProjectStats.AddIn - connected";
        }
        // EA calls this operation when it exists. Can be used to do some cleanup work.
        public void EA_Disconnect()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        // Called when user Click Add-Ins Menu item.
        public object EA_GetMenuItems(Repository repository,
            string location, string menuName)
        {
            switch (menuName)
            {
                case "":
                    return MENU_ROOT_RTI_CONNEXT;
                case MENU_ROOT_RTI_CONNEXT:
                    return MENU_ITEM_GENERATE_IDL;
            }
            return "";
        }

        // Sets the state of the menu depending if there is
        // an active project or not
        static bool EA_IsProjectOpen(Repository repository)
        {
            try
            {
                return null != repository.Models;
            }
            catch
            {
                return false;
            }
        }

        // Called once Menu has been opened to see what menu
        // items are active.
        public void EA_GetMenuState(Repository repository,
            string location, string menuName, string itemName,
            ref bool isEnabled, ref bool isChecked)
        {
            if (EA_IsProjectOpen(repository))
            {
                if (itemName == MENU_ROOT_RTI_CONNEXT)
                    isEnabled = true;
            }
            else
                // If no open project, disable all menu options
                isEnabled = false;
        }

        // Called when user makes a selection in the menu.
        // This is your main exit point to the rest of your Add-in
        public void EA_MenuClick(Repository repository,
            string location, string menuName, string itemName)
        {

            switch (itemName)
            {
                case MENU_ITEM_GENERATE_IDL:
                    IDLGenAction idlGenAction = new IDLGenAction();
                    IDLClassSelector idlClassSelector = new IDLClassSelector(idlGenAction);
                    TextBoxOutputAdapter output = new TextBoxOutputAdapter(idlClassSelector.getTextBox());
                    HashSet<string> uncheckedElements = new HashSet<string>();
                    idlGenAction.Initialize(repository, output, idlClassSelector, uncheckedElements);

                   // GenerateIDL(repository, output);

                    PopulateRepositoryClassSelector(idlClassSelector, repository);
                    idlClassSelector.Text = "IDL4 (RTI Connext DDS) - Select classes for IDL generation - Plugin revision " + IDL_GENERATOR_REVISION;
                    idlClassSelector.Show();
                    //idlGenAction.OnCodegenAction();
                    break;
            }
        }

        public static void PopulatePackageClassesAndEnums(TreeNode packageTreeNode, Package package)
        {
           foreach (Element e in package.Elements)
            {
                if (IsClass(e) || IsElementEnum(e))
                {
                    TreeNode classNode = new TreeNode(e.Name);
                    classNode.Checked = true;
                    packageTreeNode.Nodes.Add(classNode);
                }
            }
        }

        /*
         * *** This feature is not fully implemented so it is not used.***
         * 
         * The longer term objective would be to use this event to re-sync all the classes/enum with the model but only
         * at that level, not recursively
         */
        public static void ClassSelector_TreeViewAfterExpand(object sender, TreeViewEventArgs e)
        {
            return;
        }

        public static void PopulateRepositoryClassSelector(IDLClassSelector classSelector, Repository repository)
        {
            TreeNodeCollection treeNodes = classSelector.getTreeView().Nodes;


            foreach (Package model in repository.Models)
            {
                TreeNode newNode = new TreeNode(model.Name);
                newNode.Checked = true;
                newNode.Expand();
                newNode.Tag = model.Name;
                treeNodes.Add(newNode);

                foreach (Package package in model.Packages)
                {
                    PopulateClassSelector(newNode, package);
                }
            }

            // Disble because feature is not fully implemeted yet
            //classSelector.getTreeView().AfterExpand += new TreeViewEventHandler(ClassSelector_TreeViewAfterExpand);
        }

        public static void PopulateClassSelector(TreeNode parentNode, Package package)
        {
            TreeNode packageNode = new TreeNode(package.Name);
            packageNode.Checked = true;
            packageNode.Tag = package.Name;  // Store the related package
            parentNode.Nodes.Add(packageNode);

            foreach (Package p in package.Packages)
            {
                PopulateClassSelector(packageNode, p);
            }

            PopulatePackageClassesAndEnums(packageNode, package);
            packageNode.Expand();
        }

        /** Finds a child of an EA Model element capturing exceptions raised if the child is not
         * found.
         *
         */
        private static Object EAUtil_FindChild(EA.Collection collection, String childName)
        {
            Object child = null;
            try {
                child = collection.GetByName(childName);
            }
            catch (Exception) {}

            return child;
        }

        internal static void GenIDL_Preview(Repository repository, TextOutputInterface output,
            HashSet<string> uncheckedElem, String fullPath)
        {
            char[] delimiterChars = { '\\'};
            String[] elementNames = fullPath.Split(delimiterChars);
            String pathToElement = "";

            if (elementNames.Length <= 1)
            {
                GenIDL(repository, true, output, uncheckedElem);
                return;
            }

            Package package = (Package)EAUtil_FindChild(repository.Models, elementNames[0]);
            if (package == null)
            {
                output.OutputTextLine("// Could not find selected package: \"" + fullPath + "\" in the model");
                return;
            }

            Package parentPackage = package;
            Element  classElem = null;
            for (int i = 1; i < elementNames.Length; ++i, parentPackage = package)
            {
                String elemName = elementNames[i];

                package = (Package)EAUtil_FindChild(parentPackage.Packages, elemName);

                if ((package == null) && (i == elementNames.Length - 1))
                {
                    classElem = (Element)EAUtil_FindChild(parentPackage.Elements, elemName);
                }
            }

            output.Clear();
            if (package == null && classElem == null)
            {
                output.OutputTextLine("// Could not find selected element: \"" + fullPath + "\" in the model");
                return;
            }

            pathToElement = elementNames[0];
            for (int i = 1; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("module " + IDL_NormalizeUserDefinedClassifierName(elementNames[i]) + " {  ");
                pathToElement += "\\" + elementNames[i];
            }

            output.OutputTextLine();
            if (package != null)
            {
                // display package
                // output.OutputTextLine("Displaying Package: " + package.Name);
                Dictionary<long, bool> moduleRelevance = new Dictionary<long, bool>();
                HashSet<long> dummyCompletedClases = new HashSet<long>();
                UpdateModuleRelevance(moduleRelevance, package, output);
                Main.GenIDL_ModuleFirstPass(repository, package, true,
                    output, elementNames.Length - 1, pathToElement, uncheckedElem, moduleRelevance, null);
                int generatedItemCount;
                Main.GenIDL_ModuleSecondPass(repository, package, true,
                    output, elementNames.Length - 1, pathToElement,
                    out generatedItemCount, uncheckedElem, moduleRelevance, dummyCompletedClases);
            }
            else if (classElem != null)
            {
                // display class
                // output.OutputTextLine("Displaying Class: " + classElem.Name);
                if (IsElementEnum(classElem))
                {
                    Main.GenIDL_Enum(repository, classElem, output, elementNames.Length - 1, uncheckedElem, pathToElement);
                }
                else
                {
                    Main.GenIDL_Class(repository, classElem, output, elementNames.Length - 1, uncheckedElem, pathToElement);
                 }
            }
            for (int i = 1; i < elementNames.Length - 1; ++i)
            {
                output.OutputText("};");
            }
        }

        /** Outputs UML "primitive" types that are not primitive in IDL
         */
        private static void GenIDL_PrebuiltUMLTypes(TextOutputInterface output)
        {
            String builtinTypes =
                "struct dateTime { long date; long time; };";
            output.OutputTextLine(builtinTypes);
        }

        internal static void GenIDL(Repository repository, bool isPreview, TextOutputInterface output, HashSet<String> uncheckedElem)
        {
            output.Clear();

            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are UML builtin primitive types that are not primitive in IDL */");
            GenIDL_PrebuiltUMLTypes(output);
            output.OutputTextLine("");

            output.OutputTextLine("/* ******************************************************************* */");
            output.OutputTextLine("/* These are Types defined in the model */");
            output.OutputTextLine("");

            // moduleRelevance holds the modules relevant for IDL generation
            Dictionary<long, bool> moduleRelevance = new Dictionary<long, bool>();

            // completedClasses holds the classes for which code has been completely generated
            // such that we can generate code that depends on these classes
            HashSet<long> completedClasses = new HashSet<long>();

            foreach (Package model in repository.Models)
            {
                if ((!isPreview) && uncheckedElem.Contains(model.Name))
                {
                    // if unckecked skip this model
                    continue;
                }

                UpdateModuleRelevance(moduleRelevance, model, output);
            }

            foreach (Package model in repository.Models)
            {
                if ((!isPreview) && uncheckedElem.Contains(model.Name))
                {
                    // if unckecked skip this model
                    continue;
                }

                output.OutputTextLine("/* -----  Model: \"" + model.Name + "\"  ----- */");
                foreach (Package package in model.Packages)
                {
                    GenIDL_ModuleFirstPass(repository, package, false,
                        output, 0, model.Name, uncheckedElem, moduleRelevance, completedClasses);
                }
            }

            int notGeneratedClassCount = -1;        // Does not matter as long as it is < 0
            int previousNotGeneratedClassCount;

            do {
                previousNotGeneratedClassCount = notGeneratedClassCount;
                notGeneratedClassCount = 0;

                foreach (Package model in repository.Models)
                {
                    if ((!isPreview) && uncheckedElem.Contains(model.Name))
                    {
                        // if unckecked skip this model
                        continue;
                    }

                    foreach (Package package in model.Packages)
                    {
                        int generatedItemCount;
                        notGeneratedClassCount += GenIDL_ModuleSecondPass(repository, package, false,
                            output, 0, model.Name,
                            out generatedItemCount, uncheckedElem, moduleRelevance, completedClasses);
                    }
                }
            }
            while ( (notGeneratedClassCount > 0) && (notGeneratedClassCount != previousNotGeneratedClassCount) ) ;


            if (notGeneratedClassCount > 0 )
            {
                output.OutputTextLine("/* WARNING: " + notGeneratedClassCount + " classes could not be generated due to circular dependencies */");
                GenIDL_ReportUngeneratedClasses(repository, output, 0, uncheckedElem, moduleRelevance, completedClasses);
            }
        }


        private static void GenIDL_ReportUngeneratedClasses(Repository repository,
            TextOutputInterface output, int depth,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, HashSet<long> completedClasses)
        {

            output.OutputTextLine("/*");
            output.OutputTextLine("     (<package> , <class>)  depends on (<package> , <class>) by means of <relationship>");
            output.OutputTextLine("     ----------------------------------------------------------------------------------");
            foreach (Package model in repository.Models)
            {
                if (uncheckedElem.Contains(model.Name))
                {
                    // if unchecked skip this model
                    continue;
                }

                foreach (Package package in model.Packages)
                {
                    GenIDL_ReportUngeneratedClasses(repository, package, output, 0, model.Name, uncheckedElem, relevantModules, completedClasses);
                }
            }
            output.OutputTextLine("     -----------------------------------------------------------------------------------");
            output.OutputTextLine("*/");
        }

        private static void GenIDL_ReportUngeneratedClasses(Repository repository, Package package,
            TextOutputInterface output, int depth, String pathToElem,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, HashSet<long> completedClasses)
        {
            // if unchecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if (IsElementUnchecked(uncheckedElem, packageFullName))
            {
                return;
            }

            if (!IsModuleRelevant(relevantModules, package, output))
            {
                return;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);
            foreach (Element e in package.Elements)
            {
                if (!IsElementEnum(e))
                {
                    if ( ( completedClasses.Contains(e.ElementID) == false )
                        && GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, null) )
                    {
                        GenIDL_DependenciesAlreadyGenerated(repository, e, output, completedClasses, true);
                    }
                }
            }

            foreach (Package p in package.Packages)
            {
                GenIDL_ReportUngeneratedClasses(repository, p, output, depth + 1, packageFullName, uncheckedElem, relevantModules, completedClasses);
            }
        }

        private static bool IsXSDSimpleType(Element classElem)
        {
            //TODO: This is a very simplistic criteria. May need to be enhanced
            // See: http://sparxsystems.com/forums/smf/index.php/topic,30258.0.html

            return classElem.Genlinks.IndexOf("Parent=") != -1;
        }

        //TODO: IDL_XSDprimitive2IDLprimitive should be deprecated. Use IDL_NormalizeMemberTypeName() instead
        private static readonly string[] xsd_longTypes = new string[] { "long", "int", "integer", "negativeInteger", "nonPositiveInteger" };
        private static readonly string[] xsd_ulongTypes = new string[] { "unsigned long", "unsignedLong", "unsignedInt", "positiveInteger", "nonNegativeInteger" };
        private static readonly string[] xsd_ushortTypes    = new string[] { "unsigned short", "unsignedShort" };
        private static readonly string[] xsd_octetTypes     = new string[] { "octet", "byte", "unsignedByte", "sbyte" };
        private static readonly string[] xsd_stringTypes = new string[] { "string", "normalizedString", "hexBinary", "base64Binary" };
        private static readonly string[][] xsd_primtiveTypeVariations = {
                xsd_longTypes, xsd_ulongTypes, xsd_ushortTypes, xsd_octetTypes, xsd_stringTypes
            };

        private static String IDL_XSDprimitive2IDLprimitive(String xsdPrimitiveType)
        {
            for (int typeFamily = 0; typeFamily < xsd_primtiveTypeVariations.GetLength(0); ++typeFamily)
            {
                if (xsd_primtiveTypeVariations[typeFamily].Contains(xsdPrimitiveType))
                {
                    return xsd_primtiveTypeVariations[typeFamily][0];
                }
            }

            return xsdPrimitiveType;
        }

        private static void GenIDL_ClassTypedef(Element classElem, TextOutputInterface output, int depth)
        {

            // output.OutputTextLine(depth, "// Debug Genlinks: " + classElem.Genlinks);
            // output.OutputTextLine(depth, "// Debug EmbeddedElements count: " + classElem.EmbeddedElements.Count);

            // Look to see if this class is just an alias for another as would happen for an xsd:simpleType
            if ( !IsXSDSimpleType(classElem) ) {
                output.OutputTextLine(depth, "struct " + IDL_NormalizeUserDefinedClassifierName(classElem.Name) + ";");
                return;
            }

            // Else it is a XSD simpleType. Find the base type and generate a typedef for it
            String genLinks = classElem.Genlinks;
            String genLinksBaseClass = null;
            if (genLinks != null)
            {
                String parentIdentifier = "Parent=";
                int parentBeginIndex = genLinks.IndexOf(parentIdentifier);

                if (parentBeginIndex >= 0)
                {
                    parentBeginIndex += parentIdentifier.Length;
                    int parentEndIndex = genLinks.IndexOf(";", parentBeginIndex);
                    if (parentEndIndex < 0)
                    {
                        parentEndIndex = genLinks.Length;
                    }

                    genLinksBaseClass = genLinks.Substring(parentBeginIndex, parentEndIndex - parentBeginIndex);
                }
            }

            if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
            {
                output.OutputTextLine(depth, "/* Mapping to typedef because generated links are: " + genLinks + " */");
            }
            String primitiveIDLType = IDL_XSDprimitive2IDLprimitive(genLinksBaseClass);
            output.OutputTextLine(depth, "typedef " + primitiveIDLType + " " + IDL_NormalizeUserDefinedClassifierName(classElem.Name) + ";");
            return;
        }

        /** Generate IDL4 module corresponding to the UML package
         *
         *  This function is the first-pass module generation. It generates the things that
         *  have no dependencies on anything else and help resolve dependencies for the types
         *  that depend on this module. These are:
         *
         *  enums
         *  typedefs for all structures defined in the module.
         *
         *  This function is recursive. It generates IDL for all the nested UML packages as well
         *
         *
         */
        private static void GenIDL_ModuleFirstPass(Repository repository, Package package, bool forceSelection,
            TextOutputInterface output, int depth, String pathToElem,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules, HashSet<long> completedClasses)
        {
            // if unckecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if ( (!forceSelection) && IsElementUnchecked(uncheckedElem, packageFullName))
            {
                return;
            }

            if ( !IsModuleRelevant(relevantModules, package, output) )
            {
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Skipping empty module: \"" + package.Name + "\" */");
                }
                return;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);
            bool emptyModuleContent = true;
            output.OutputTextLine(depth, "module " + moduleName + " {");

            foreach (Element e in package.Elements)
            {
                if (IsElementUnchecked(uncheckedElem, packageFullName, e.Name))
                {
                    continue;
                }

                if (IsElementEnum(e))
                {
                    GenIDL_Enum(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                    if ( completedClasses != null ) {
                        completedClasses.Add(e.ElementID);
                    }
                    emptyModuleContent = false;
                }
                else
                {
                    if (GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, null))
                    {
                        GenIDL_ClassTypedef(e, output, depth + 1);
                        emptyModuleContent = false;
                    }
                }
            }

            foreach (Package p in package.Packages)
            {
                GenIDL_ModuleFirstPass(repository, p, false,
                    output, depth + 1, packageFullName, uncheckedElem, relevantModules, completedClasses);
                emptyModuleContent = false;
            }

            if (emptyModuleContent)
            {
                GenIDL_EmptyModuleContent(moduleName, output, depth + 1);
            }
            output.OutputTextLine(depth, "}; /* module " + moduleName + " */");
            output.OutputTextLine();
        }

        /** Generate IDL4 module corresponding to the UML package
         *
         *  This function is recursive. It generates IDL for all the nested UML packages and classes
         *
         * Returns the number of classes for which IDL could not be generated due to dependencies.
         *
         * The IDL for a class "C" can only be generated if we have already generated the IDL for all
         * the classes "C" depends on. This is determined by the return of the function:
         * GenIDL_DependenciesAlreadyGenerated()
         *
         * A return of "0" indicates there were no relevant classes for which the IDL could not be
         * generated. That is, the IDL generation is complete.
         *
         * A return >0 indicates IDL generation is not complete. In this case the GenIDL_ModuleSecondPass()
         * could be called again to generate additional classes that may have had their dependent
         * classes generated in the previous pass.
         *
         * If two successive calls to GenIDL_ModuleSecondPass() return the same value. That is, no progress
         * was made in on pass, this indicates there is a cyclic dependency that cannot be resolved.
         * In this case the strategy is to report the error so the user can break the dependency by, for example,
         * declaring on of the dependencies in the link as "@Shared"
         */
        private static int GenIDL_ModuleSecondPass(Repository repository, Package package, bool forceSelection,
            TextOutputInterface output, int depth, String pathToElem, out int generatedItemCount,
            HashSet<String> uncheckedElem, Dictionary<long, bool> relevantModules,HashSet<long> completedClasses )
        {
            int notGeneratedClassCount = 0;
            generatedItemCount = 0;

            // if unckecked skip this model
            String packageFullName = IDL_FullElementName(pathToElem, package.Name);
            if ( (!forceSelection) && IsElementUnchecked(uncheckedElem, packageFullName) )
            {
                return 0;
            }

            if (!IsModuleRelevant(relevantModules, package, output))
            {
                return 0;
            }

            if (completedClasses.Contains(package.PackageID))
            {
                return 0;
            }

            String moduleName = IDL_NormalizeUserDefinedClassifierName(package.Name);

            int moduleOutputPosition = output.GetCurrentPosition();
            output.OutputTextLine(depth, "module " + moduleName + " {");

            foreach (Element e in package.Elements)
            {
                // Skip Enum as they are generated on the first pass
                if ( !IsElementEnum(e) )
                {
                    if (GenIDL_MustGenerateClass(repository, e, packageFullName, uncheckedElem, completedClasses))
                    {
                        if ( GenIDL_DependenciesAlreadyGenerated(repository, e, output, completedClasses, false) )
                        {
                            GenIDL_Class(repository, e, output, depth + 1, uncheckedElem, packageFullName);
                            ++generatedItemCount;
                            completedClasses.Add(e.ElementID);
                        }
                        else
                        {
                            ++notGeneratedClassCount;
                        }
                    }
                }
            }

            foreach (Package p in package.Packages)
            {
                int subModuleGeneratedItemCount;
                int submoduleNonGenClassCount = GenIDL_ModuleSecondPass(repository, p, false,
                    output, depth + 1, packageFullName,
                    out subModuleGeneratedItemCount, uncheckedElem, relevantModules, completedClasses);
                notGeneratedClassCount += submoduleNonGenClassCount;
                generatedItemCount += subModuleGeneratedItemCount;

                if (submoduleNonGenClassCount == 0)
                {
                    // module is complete
                    completedClasses.Add(p.PackageID);
                }
            }

            if (generatedItemCount == 0)
            {
                GenIDL_EmptyModuleContent(moduleName, output, depth + 1);
                output.ClearPositionRange(moduleOutputPosition, output.GetCurrentPosition());
            }
            else
            {
                output.OutputTextLine(depth, "}; /* module " + moduleName + " */");
                output.OutputTextLine();
            }

            return notGeneratedClassCount;
        }


        /* Generate the IDL for an enum literal.
         */
        private static void GenIDL_EnumLiterals(Repository repository, String enumName, Element enumElem, TextOutputInterface output, int depth)
        {
            short childCount = enumElem.Attributes.Count;
            for (short i = 0 ; i < childCount; ++i )
            {
                EA.Attribute child = enumElem.Attributes.GetAt(i);
                // String typeName = IDL_NormalizeMemberTypeName(child.Type);

                // Handle enumeration values. The "default value set in UML takes precedence
                // if not then look at the tag Value
                int value;
                String valueAnnotation = null;
                if (Int32.TryParse(child.Default, out value))
                {
                    valueAnnotation = child.Default;
                    // output.OutputText(" //@Value " + child.Default);
                }
                else
                {
                    string[] relevantAnnotationsWithValue = new string[] {
                        "ID", "Value"
                    };

                    foreach (AttributeTag tag in child.TaggedValues)
                    {
                        String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);
                        if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                        {
                            valueAnnotation = tag.Value;
                        }
                    }
                }

                if ( (idlVersion >= IDLVersion.IDL_V400) && (valueAnnotation != null) )
                {
                    GenIDL_Annotation("Value", valueAnnotation, true, output, depth);
                }

                output.OutputText(depth, enumName + "_" + child.Name);

                if ((idlVersion == IDLVersion.IDL_V350_CONNEXT52) && (valueAnnotation != null))
                {
                    output.OutputText(" = " + valueAnnotation);
                }
                if (i < childCount - 1)
                {
                    output.OutputText(",");
                }

                if ((idlVersion == IDLVersion.IDL_V350_XTYPES) && (valueAnnotation != null))
                {
                    GenIDL_Annotation("Value", valueAnnotation, true, output, depth);
                }

                output.OutputTextLine();
            }
        }

        private static String GenIDL_GetFullPackageName(Repository repository, Element elem)
        {
            String packageName = "";
            int packageID = elem.PackageID;
            Package package = repository.GetPackageByID(packageID);
            int parentPackageID = package.ParentID;

            while (parentPackageID != 0)
            {
                packageName = IDL_NormalizeUserDefinedClassifierName(package.Name) + "::" + packageName;
                packageID = parentPackageID;
                package = repository.GetPackageByID(packageID);
                parentPackageID = package.ParentID;
            }

            return packageName;
        }

        /* Generate the IDL for an attribute.
         * The attribute can appear by itself, a sequence, or an array.
         * The determination of this is based on the settings of LowerBound and UpperBound
         *
         *    UpperBound == 0                 ==>  Unbounded Sequence
         *    LowerBound == UpperBound == 1        ==>  Single member (no Array/Sequence)
         *    LowerBound == 0 && UpperBound == 1   ==>  Optional single member
         *
         *    LowerBound  < UpperBound  (other values)    ==>  Bounded Sequence
         *    LowerBound == UpperBound  (other values)    == > Array
         *
         * returns true if it outputs some attribute; otherwise returns false
         */
        private static bool GenIDL_Attributes(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            if (classElem.Attributes.Count == 0)
            {
                return false;
            }

            foreach (EA.Attribute child in classElem.Attributes)
            {
                // This does not get the fully qualified type name. We need that to fully resolve
                // the type in the IDL...
                String typeName;

                /* This code was trying to get the fully-qualified name but it throws an exception
                 */
                if ( child.ClassifierID == 0 ) {
                    typeName = IDL_NormalizeMemberTypeName(child.Type);
                }
                else {
                    Element attributeType = repository.GetElementByID(child.ClassifierID);
                    Package attributePackage = repository.GetPackageByID(attributeType.PackageID);
                    typeName = GenIDL_GetFullPackageName(repository, attributeType)
                        + IDL_NormalizeMemberTypeName(attributeType.Name);
                }

                int lower  = 0;
                int upper  = 0;
                try {
                    lower = Convert.ToInt32(child.LowerBound);
                } catch (Exception) {}
                try {
                    upper = Convert.ToInt32(child.UpperBound);
                } catch (Exception) { }

                int attributeDepth = depth;

                String effectiveTypeName   = typeName;
                String effectiveMemberName = child.Name;
                String extraAnnotation = null;
                if (upper == 0) // Unbounded sequence
                {
                    //output.OutputText(attributeDepth, "sequence<" + typeName + "> " + child.Name + ";");
                    effectiveTypeName = "sequence<" + typeName + ">";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "// Mapping to unbounded sequence because (upper bound == 0)");
                    }

                }
                else if (lower == upper)
                {
                    if (upper != 1)  // Array
                    {
                        effectiveMemberName = child.Name + "[" + child.UpperBound + "]";
                        if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                        {
                            output.OutputTextLine(depth, "// Mapping to array because (lower bound == upper bound)");
                        }
                    }
                }
                else if (lower == 0 && upper == 1)
                {
                    // Handle this the same as an @optional annotation
                    extraAnnotation = "Optional";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "// Mapping to optional because (lower bound == 0 && upper bound == 1)");
                    }

                }
                else // bounded sequence
                {
                    effectiveTypeName = "sequence<" + typeName + "," + child.UpperBound + ">";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "// Mapping to bounded sequence because (lower bound < upper bound)");
                    }
                }

                GenIDL_AttributeWithAnnotations(child, effectiveTypeName, effectiveMemberName, extraAnnotation, output, depth);
                output.OutputTextLine();
            }

            return true;
        }

        private static void GenIDL_AttributeWithAnnotations(EA.Attribute child,
            String effectiveType, String effectiveName, String extraAnnotation,
            TextOutputInterface output, int depth)
        {
            int annotationCount = 0;
            if (idlVersion >= IDLVersion.IDL_V400)
            {
                annotationCount = GenIDL_AttributeAnnotations(child, output, depth);
                if (extraAnnotation != null)
                {
                    GenIDL_Annotation(extraAnnotation, annotationCount==0, output, depth);
                    ++annotationCount;
                }
            }
            output.OutputText(depth, effectiveType + " " + effectiveName + ";");

            if (idlVersion < IDLVersion.IDL_V400)
            {
                annotationCount = GenIDL_AttributeAnnotations(child, output, depth);
                if (extraAnnotation != null)
                {
                    GenIDL_Annotation(extraAnnotation, annotationCount==0, output, depth);
                    ++annotationCount;
                }
            }
        }

        private static void GenIDL_Annotation(
            String annotationName, bool firstAnnotation,
            TextOutputInterface output, int depth)
        {
            GenIDL_Annotation(annotationName, null, firstAnnotation, output, depth);
        }

        private static void GenIDL_Annotation(
            String annotationName, String annotationParam1, bool firstAnnotation,
            TextOutputInterface output, int depth)
        {
            if (idlVersion >= IDLVersion.IDL_V400)
            {
                output.OutputText(depth, "@" + annotationName.ToLower());
                if (annotationParam1 != null)
                {
                    output.OutputText("(" + annotationParam1 + ") ");
                }
                output.OutputTextLine();
            }
            else if (idlVersion >= IDLVersion.IDL_V350_XTYPES)
            {
                output.OutputText("  //@" + annotationName);
                if (annotationParam1 != null)
                {
                    output.OutputText("(" + annotationParam1 + ") ");
                }
            }
            else
            {
                if (firstAnnotation)
                {
                    output.OutputText("  //@" + annotationName);
                }
                else {
                    output.OutputTextLine();
                    output.OutputText(depth, "    //@" + annotationName);
                }

                if (annotationParam1 != null)
                {
                    output.OutputText(" " + annotationParam1);
                }
            }
        }

        /** Outputs the annotations associated with the attribute
         *
         * Returns the number of annotations printed
         */
        private static int GenIDL_AttributeAnnotations(EA.Attribute child, TextOutputInterface output, int depth)
        {
            string keyAnnotation = "Key";
            string[] relevantAnnotationsNoValue = new string[] {
                    keyAnnotation,
                    "must_understand",
                    "autoid", "Optional",
                    "external", "nested",
                    "oneway", "ami"
                };
            string[] relevantAnnotationsWithValue = new string[] {
                    "ID", "Value"
                };

            string ddsTag = "DDS";

            Boolean mappedToKey = false;
            int annotationCount = 0;

            foreach (AttributeTag tag in child.TaggedValues)
            {
                String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);

                // Accept the TagName DDS as an alternative way to provide an accepted no value annotation
                // So {Tag, Value} = {"DDS", "XYZ"} is equivalent to {"XYZ", }
                if (normalizedAnnotation.Equals(ddsTag))
                {
                    normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Value);
                }

                if (relevantAnnotationsNoValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, annotationCount==0, output, depth);
                    ++annotationCount;
                    if ( normalizedAnnotation.Equals(keyAnnotation) ) {
                        mappedToKey = true;
                    }
                }
                else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, tag.Value, annotationCount == 0, output, depth);
                    ++annotationCount;
                }
                else
                {
                    if ((idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL))
                    {
                        output.OutputTextLine(depth, "/* Skipping unknown annotation name: \"" + tag.Name + "\" value: \"" + tag.Value + "\" */");
                    }
                }
            }

            // Accept the attributes marked as ID as being "Key"
            if ( (!mappedToKey) && child.IsID )
            {
                mappedToKey = true;
                GenIDL_Annotation(keyAnnotation, annotationCount == 0, output, depth);
                ++annotationCount;
                if ((idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL))
                {
                    output.OutputTextLine(depth, "/* Mapping to @Key because attribute has the IsID property set */");
                }
            }


            return annotationCount;
        }

        /*
         * Determinies member name used when a member is created as a result of a reference to some other class/element
         * The member name is chosen following a set of rules to it is the "most natural one" accoding to whether the user
         * has explicitly named the role, reference, etc.
         * The criteria is:
         *   - Use the rolename if present
         *   - Else use the relationship name
         *   - Else use the name of the target class starting with lower case, or preceeded with a "m_"
         *   
         * Names are always normalized to prevent using characters that would be invalid as a member name
         * When the classname is used a "numeric suffix" is used to prevent multiple references to the same
         * class resulting on member name collisions
         */
        private static String GenIDL_GetReferenceName(EA.Connector conn, EA.ConnectorEnd referencedElemEnd, EA.Element referencedElem)
        {
            String refName = referencedElemEnd.Role;
            if ( refName.Equals("") )  {
                refName = conn.Name;
            }
            if (refName.Equals(""))    {
                char firstLetter = referencedElem.Name[0];
                if ( char.IsUpper(firstLetter) )  {
                    refName = char.ToLower(firstLetter) + referencedElem.Name.Substring(1);
                }
                else {
                    refName = "m_" + referencedElem.Name;
                }
            }

            return IDL_NormalizeUserDefinedClassifierName(refName);
        }

        private static void GenIDL_ReferenceDescriptor(
            EA.Repository repository, EA.Connector conn, int sourceElemId, bool explain,
            out EA.ConnectorEnd sourceElemEnd, out EA.ConnectorEnd referencedElemEnd, 
            out int referencedElemId, out EA.Element referencedElem,
            out bool includeInSourceElem, out String explanation)
        {
            if (sourceElemId == conn.ClientID)
            {
                sourceElemEnd = conn.ClientEnd;
                referencedElemEnd = conn.SupplierEnd;
                referencedElemId = conn.SupplierID;
            }
            else
            {
                sourceElemEnd = conn.SupplierEnd;
                referencedElemEnd = conn.ClientEnd;
                referencedElemId = conn.ClientID;
            }

            referencedElem = repository.GetElementByID(referencedElemId);
            includeInSourceElem = false;
            explanation = null;

            // Only consider "Aggregation" and "Association" relationships as reasons to include the
            // referenced element as a member
            string[] relevantConnectorTypes = new string[] { "Association", "Aggregation", "Nesting" };
            if (!relevantConnectorTypes.Contains(conn.Type))
            {
                if (explain)
                {
                    explanation = "association type is '" + conn.Type + "' instead of 'Association', 'Aggregation', or 'Nesting'";
                }
                return;
            }

            if (referencedElemEnd.IsNavigable == false)
            {
                if (explain)
                {
                    explanation = "target role Navigability property is false";
                }
                return;
            }

            if (sourceElemEnd.Aggregation == 0)
            {
                if (explain)
                {
                    explanation = "source role Aggegation property is 'none' instead of 'shared' or 'composite'";
                }
                return;
            }


            if (conn.Type.Equals("Association") && !referencedElemEnd.Containment.Equals("Value"))
            {
                if (explain)
                {
                    explanation = "target role containment type is '"  + referencedElemEnd.Containment + "' instead of 'Value'";
                }
                return;
            }


  
            if (referencedElem == null)
            {
                if (explain)
                {
                    explanation = "target element with ElementID = " + referencedElemId + " is not found in UML Repository";
                }
                return;
            }

            includeInSourceElem = true;
            return;
        }

        /**
         * Determines if the relationship to the referenced type is such that the referenced type
         * should be included as part of the referencing type.
         *
         * Returns the fully qualified normalized name for the referenced type in case it needs to be included
         * and null if it does need to be included.
         *
         * Currently we include the referenced type if an only if the relationship is of type "Aggregation" and it is
         * navigable from Element classElem to the referenced element.
         * This means that we ignore relationships of kind "Association"
         */
        private static String GenIDL_GetReferencedTypeToInclude(
            out String annotation, out String memberName,
            Repository repository,
            Element classElem, EA.Connector conn, TextOutputInterface output, int depth)
        {
            annotation = null;
            memberName    = null;

            // Generalization (Inheritance) does not cause the referenced element to 
            // appear as member. This is well understood so no need to report more details on why
            if (conn.Type.Equals("Generalization"))
            {
                return null;
            }

            Element referencedElem;
            ConnectorEnd thisElemEnd;
            ConnectorEnd referencedElemEnd;
            int referencedElemId;
            String explanation;
            bool includeReferencedTypeAsMember;

            bool reportExplanationText = idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_BASIC;

            GenIDL_ReferenceDescriptor(repository, conn, classElem.ElementID, reportExplanationText,
                out thisElemEnd, out referencedElemEnd, out referencedElemId, out referencedElem, 
                out includeReferencedTypeAsMember, out explanation);

            memberName = GenIDL_GetReferenceName(conn, referencedElemEnd, referencedElem);
            if ( !includeReferencedTypeAsMember ) {
                if ( reportExplanationText ) {
                    String referencedElementClassName = "Unknown Type";
                    if (referencedElem != null)
                    {
                        referencedElementClassName = referencedElem.Name;
                    }

                    output.OutputTextLine(depth, "/* Skipping reference \"" + memberName
                        + "\" to element \"" + referencedElementClassName + "\" because " + explanation + " */");
                }
                return null;
            }

            /* If we are here we know includeReferencedTypeAsMember == TRUE
             * this means referenced class as a member of this element 
             * and also that referencedElem != null as this is checked as part of the condition to include that class */
            String memberTypeScoped = null;
            String cardinality = referencedElemEnd.Cardinality;
           

            String normalizedMemberType = IDL_NormalizeMemberTypeName(referencedElem.Name);
            memberTypeScoped = GenIDL_GetFullPackageName(repository, referencedElem) + normalizedMemberType;

            if (cardinality.Equals("") || cardinality.Equals("1") || cardinality.Equals("0"))
            {
                // Use pointer notation for IDL_V350_CONNEXT52
                if (idlVersion == IDLVersion.IDL_V350_CONNEXT52)
                {
                    memberTypeScoped = memberTypeScoped + "*";
                }
                else // Otherwise use an annotation
                {
                    annotation = "@Shared";
                }
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to Shared because relation cardinality == 1 (or is unspecified) */");
                }
            }
            else if (cardinality.Equals("*") || cardinality.EndsWith("..*"))
            {
                // No upper limit -> unbounded sequence
                memberTypeScoped = "sequence<" + memberTypeScoped + ">";
                if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                {
                    output.OutputTextLine(depth, "/* Mapping to unbounded sequence because relation cardinality is \"*\" (or \"..*\") */");
                }
            }
            else
            {
                // Bounded sequence
                int upperLimit = 0;
                if (Int32.TryParse(cardinality, out upperLimit))
                {
                    if (upperLimit <= 0) { upperLimit = 1; }
                    memberTypeScoped = "sequence<" + memberTypeScoped + "," + upperLimit + ">";
                    if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                    {
                        output.OutputTextLine(depth, "/* Mapping to bounded sequence because relationship cardinality = "
                                                    + cardinality + " (lower bound < upper bound) */");
                    }
                }
                else
                {
                    int limitPos = cardinality.LastIndexOf("..");
                    if ((limitPos != -1) &&
                            Int32.TryParse(cardinality.Substring(limitPos + 2), out upperLimit))
                    {
                        memberTypeScoped = "sequence<" + memberTypeScoped + "," + upperLimit + ">";
                        if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                        {
                            output.OutputTextLine(depth, "/* Mapping to bounded sequence because relationship cardinality = "
                                                        + cardinality + " (lower bound < upper bound) */");
                        }
                    }
                    else
                    {
                        memberTypeScoped = "sequence<" + memberTypeScoped + ">";
                        if (idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL)
                        {
                            output.OutputTextLine(depth, "/* Mapping to unbounded sequence because relationship cardinality = "
                                                        + cardinality + " */");
                        }
                    }
                }
                
            }

            return memberTypeScoped;
        }

        //TODO: This should examine the relationship and determine the multiplicity so that
        //      the relationship can be generated as a sequence rather than single reference.
        private static bool GenIDL_Relations(Repository repository, Element classElem, TextOutputInterface output, int depth)
        {
            bool generatedRelationship = false;

            foreach (EA.Connector conn in classElem.Connectors)
            {
                String annotation = null;
                String refname = null;
                String referencedType = GenIDL_GetReferencedTypeToInclude(out annotation, out refname, repository, classElem, conn, output, depth);

                if (referencedType != null)
                {
                    if (annotation != null)
                    {
                        if (idlVersion >= IDLVersion.IDL_V400)
                        {
                            output.OutputText(depth, annotation + " ");
                            output.OutputTextLine(referencedType + "  " + refname + "; ");
                        }
                        else
                        {
                            output.OutputTextLine(depth, referencedType + "  " + refname + "; //" + annotation);
                        }
                    }
                    else
                    {
                        output.OutputTextLine(depth, referencedType + "  " + refname + ";");
                    }
                    generatedRelationship = true;
                }
            }

            return generatedRelationship;
        }

        private static String IDL_FullElementName(String elementPath, String elementName)
        {
            return elementPath + "\\" + elementName;
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementFullName)
        {
            return (uncheckedElem != null) && (uncheckedElem.Contains(elementFullName));
        }

        private static bool IsElementUnchecked(HashSet<String> uncheckedElem, String elementPath, String elementName)
        {
            if (uncheckedElem == null)
            {
                return false;
            }
            return uncheckedElem.Contains(IDL_FullElementName(elementPath, elementName));
        }

        private static bool IsElementEnum(Element elem)
        {
            return elem.Type.Equals("Enumeration") || elem.Stereotype.Equals("enumeration");
        }

        /**
         *  This function traverses the package, recursively visiting all its children, and updates
         *  the moduleRelevance dictionary storing whether each individual module is relevant or not
         *
         * Relevance is currently defined as not being empty for the purposes of IDL generation. This
         * means having some class, some enumeration, or recursively containing a relevant sub-package
         */
        private static bool UpdateModuleRelevance(Dictionary<long, bool> moduleRelevance, Package package,
            TextOutputInterface output)
        {
            bool relevantModule = false;

            foreach (Package p in package.Packages)
            {
                relevantModule = UpdateModuleRelevance(moduleRelevance, p, output) || relevantModule;
            }

            if (relevantModule == false)
            {
                foreach (Element e in package.Elements)
                {
                    if (IsElementEnum(e) || IsClass(e))
                    {
                        relevantModule = true;
                        break;
                    }
                }
            }
            moduleRelevance.Add(package.PackageID, relevantModule);

            return relevantModule;
        }

        private static bool IsModuleRelevant(Dictionary<long, bool> moduleRelevance, Package package, TextOutputInterface output)
        {
            bool isRelevant = true;
            if (!moduleRelevance.TryGetValue(package.PackageID, out isRelevant))
            {
                output.OutputTextLine("IsModuleRelevant; Error did not find: " + package.Name);
                return true;
            }
            return isRelevant;
        }

        private static void GenIDL_Enum(Repository repository, Element enumElem,
             TextOutputInterface output, int depth,
             HashSet<String> uncheckedElem, String elementPath)
        {
            String enumNameNormalized = IDL_NormalizeUserDefinedClassifierName(enumElem.Name);
            output.OutputTextLine(depth,
                "enum " + enumNameNormalized + " {");

            //output.OutputTextLine(depth, "/* elementID = " + enumElem.ElementID + " */");
            GenIDL_EnumLiterals(repository, enumNameNormalized, enumElem, output, depth + 1);
            output.OutputTextLine(depth, "};");
        }

        private static bool GenIDL_MustGenerateClass(Repository repository, Element classElem,
             String elementPath, HashSet<String> uncheckedElem, HashSet<long> completedClasses)
        {
            // Check that it is a class
            if (!IsClass(classElem))
            {
                return false;
            }

            // If already generated skip class
            if ( (completedClasses != null) && completedClasses.Contains(classElem.ElementID) )
            {
                return false;
            }

            // If unchecked, skip class
            if (IsElementUnchecked(uncheckedElem, elementPath, classElem.Name))
            {
                return false;
            }

            return true;
        }

        private static void GenIDL_EmptyClassContent(String className,
            TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "octet __dummy_prevent_empty_class_" + IDL_NormalizeUserDefinedClassifierName(className) + ";");
        }

        private static void GenIDL_EmptyModuleContent(String moduleName,
            TextOutputInterface output, int depth)
        {
            output.OutputTextLine(depth, "const long EmptyModule_Sentinel_" + moduleName + " = 0;");
        }

        /**
         * Checks that all the definitions this class depends on are already generated
         * This includes the base classes as well as any types that appear as
         * attributes and are not marked "@Shared"
         *
         */
        private static bool GenIDL_DependenciesAlreadyGenerated(Repository repository, Element classElem,
            TextOutputInterface output, HashSet<long> completedClasses, bool outputReport)
        {

            //output.OutputTextLine("// GenIDL_DependenciesAlreadyGenerated Checking: " + classElem.Name);

            // Check base classes
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                if (!completedClasses.Contains(elem.ElementID))
                {
                    if (outputReport)
                    {
                        output.OutputText("    ( \"" + GenIDL_GetFullPackageName(repository, classElem) + "\" , \"" + classElem.Name + "\" )");
                        output.OutputText("  depends on  ( " + GenIDL_GetFullPackageName(repository, elem) + "\" , \"" + elem.Name + "\" )");
                        output.OutputTextLine("  dependency: baseclass");
                    }
                    return false;
                }
            }

            // Check atributes
            foreach (EA.Attribute child in classElem.Attributes)
            {
               if (child.ClassifierID == 0) /* Primitive type */
                {
                    continue;
                }
                if (!completedClasses.Contains(child.ClassifierID))
                {
                    // Not generated yet. It is only OK if this is by reference
                    if ( !IsAttributeReference(child) )
                    {
                        if (outputReport)
                        {
                            Element childTypeElem = repository.GetElementByID(child.ClassifierID);
                            output.OutputText("    ( \"" + GenIDL_GetFullPackageName(repository, classElem) + "\" , \"" + classElem.Name + "\" )");
                            output.OutputText("  depends on  ( " + GenIDL_GetFullPackageName(repository, childTypeElem) + "\" , \"" + childTypeElem.Name + "\" )");
                            output.OutputTextLine("   dependency:  attribute \"" + child.Name + "\"");
                        }

                        return false;
                    }
                }
            }

            // Check relationships (Aggregations only)
            String explanation;
            foreach (EA.Connector conn in classElem.Connectors)
            {
                ConnectorEnd thisElemEnd;
                ConnectorEnd referencedElemEnd;
                int referencedElemId;
                Element referencedElem;
                bool includeReferencedTypeAsMember;

                // Resolve the reference but ommit any explanatory text
                GenIDL_ReferenceDescriptor(repository, conn, classElem.ElementID, false,
                                            out thisElemEnd, out referencedElemEnd, out referencedElemId, out referencedElem,
                                            out includeReferencedTypeAsMember, out explanation);

                // If the reference did not have to be included, there there is no dependency on it.
                if ( includeReferencedTypeAsMember == false ) {
                    continue;
                }

                // If we are here then the referenced element must appear as a member. There is a depedency so we must make sure
                // that that class has already been generated
                if (!completedClasses.Contains(referencedElemId))
                {
                    if (outputReport)
                    {
                        output.OutputText("    ( \"" + GenIDL_GetFullPackageName(repository, classElem) + "\" , \"" + classElem.Name + "\" )");
                        output.OutputText("  depends on  ( " + GenIDL_GetFullPackageName(repository, referencedElem) + "\" , \"" + referencedElem.Name + "\" )");
                        output.OutputTextLine("   dependency:  aggregation \"" + GenIDL_GetReferenceName(conn, referencedElemEnd, referencedElem) + "\"");
                    }

                    return false;
                }
            }

            return true;
        }

        /**
         *  Determines whether the attribute links the member by reference
         *  indicating that the type of the attribute does not need to be fully declared by
         *  the time we generate the IDL for the containing class.
         *
         *  This is true for attributes tagged "@Shared" and maybe others as well
         */
        private static bool IsAttributeReference(EA.Attribute member)
        {
            return (member.TaggedValues != null) && (EAUtil_FindChild(member.TaggedValues, "//@Shared") != null);
        }

        private static void GenIDL_Class(Repository repository, Element classElem,
            TextOutputInterface output, int depth,
            HashSet<String> uncheckedElem, String elementPath)
        {
            // Check if this was a XSD simpleType if so there is nothing to do because we already generated
            // a typedef for it...
            if (IsXSDSimpleType(classElem))
            {
                return;
            }

            String className = IDL_NormalizeUserDefinedClassifierName(classElem.Name);
            String baseClassName = null;
            if (classElem.BaseClasses.Count > 0)
            {
                Object obj = classElem.BaseClasses.GetAt(0);
                Element elem = (Element)obj;
                baseClassName = GenIDL_GetFullPackageName(repository, elem)
                    + IDL_NormalizeUserDefinedClassifierName(elem.Name);

                if (baseClassName == null)
                {
                    output.OutputText(depth, "/* Warning: empty base class ommitted for " + classElem.Name + "*/");
                }
            }



            // In IDL4 and higher annotations are before the class
            if  (idlVersion >= IDLVersion.IDL_V400) {
                GenIDL_ClassAnnotation(classElem, output, depth);
            }
            output.OutputText(depth, "struct " + className);

            if (baseClassName != null)
            {
                output.OutputText(" : " + baseClassName);
            }
            output.OutputTextLine(" {");

            bool emptyClassContent = true;
            if (GenIDL_Attributes(repository, classElem, output, depth + 1))
            {
                emptyClassContent = false;
            }
            if (GenIDL_Relations(repository, classElem, output, depth + 1))
            {
                emptyClassContent = false;
            }

            if (emptyClassContent)
            {
                GenIDL_EmptyClassContent(className, output, depth + 1);
            }
            output.OutputText(depth, "};");

            // In IDL35 annotations may appear after the class as a comment
            if (idlVersion < IDLVersion.IDL_V400)
            {
                GenIDL_ClassAnnotation(classElem, output, depth);
            }
            output.OutputTextLine();
        }

        private static int GenIDL_ClassAnnotation(Element classElem,
            TextOutputInterface output, int depth)
        {
            string[] relevantAnnotationsNoValue = new string[] {
                "autoid",
                "final", "mutable", "extensible",
                "nested",
                "service"
            };
            string[] relevantAnnotationsWithValue = new string[] {
                "Extensibility", "verbatim"
            };

            string ddsTag = "DDS";

            int annotationCount = 0;
            foreach (TaggedValue tag in classElem.TaggedValues)
            {
                String normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Name);

                // Accept the TagName DDS as an alternative way to provide an accepted no value annotation
                // So {Tag, Value} = {"DDS", "XYZ"} is equivalent to {"XYZ", }
                if (normalizedAnnotation.Equals(ddsTag))
                {
                    normalizedAnnotation = IDL_NormalizeAnnotationName(tag.Value);
                }

                if (relevantAnnotationsNoValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, annotationCount == 0, output, depth);
                    output.OutputTextLine();
                    ++annotationCount;
                }
                else if (relevantAnnotationsWithValue.Contains(normalizedAnnotation))
                {
                    GenIDL_Annotation(normalizedAnnotation, tag.Value, annotationCount == 0, output, depth);
                    output.OutputTextLine();
                    ++annotationCount;
                }
                else
                {
                    if ((idlMappingDetail >= IDLMappingDetail.IDL_DETAILS_FULL))
                    {
                        output.OutputTextLine(depth, "/* Skipping unknown annotation name:\"" + tag.Name + "\" value: \"" + tag.Value + "\" */");
                    }
                }
            }

            return annotationCount;
        }


        private static char[] invalidTypenameChars = new char[] { ' ', '-', '&', '(', ')' };

        /**  Normalizes a user-defined UML classifier (class / package) name into a legal IDL class/module name
         *
         */
        public static String IDL_NormalizeUserDefinedClassifierName(String classifierName)
        {
            for (int index = 0; index < invalidTypenameChars.GetLength(0); ++index) {
                classifierName = classifierName.Replace(invalidTypenameChars[index], '_');
            }

            return classifierName;
        }

        private static readonly string[] boolTypes      = new string[] { "boolean", "bool" };
        private static readonly string[] charTypes      = new string[] { "char" };
        private static readonly string[] wcharTypes     = new string[] { "wchar", "wchar_t" };

        private static readonly string[] longlongTypes  = new string[] { "long long", "int64", "int64_t" };
        private static readonly string[] ulonglongTypes = new string[] { "unsigned long long", "uint64", "uint64_t" };
        private static readonly string[] longTypes      = new string[] { "long", "int", "int32", "int32_t", "integer", "decimal", "unlimitednatural"};
        private static readonly string[] ulongTypes     = new string[] { "unsigned long", "unsigned int", "ulong", "uint", "uint32", "uint32_t" };
        private static readonly string[] shortTypes     = new string[] { "short", "int16", "int16_t" };
        private static readonly string[] ushortTypes    = new string[] { "unsigned short", "ushort", "uint16", "uint16_t" };
        private static readonly string[] octetTypes     = new string[] { "octet", "byte", "sbyte", "int8", "int8_t", "uint8", "uint8_t" };
        private static readonly string[] floatTypes     = new string[] { "float", "float32", "number", "real" };
        private static readonly string[] doubleTypes    = new string[] { "double", "float64" };
        private static readonly string[] stringTypes    = new string[] { "string", "String" };
        private static readonly string[] wstringTypes   = new string[] { "wstring" };

        private static readonly string[][] primtiveTypeVariations = {
            boolTypes, charTypes, wcharTypes, 
            longlongTypes, ulonglongTypes, longTypes, ulongTypes, shortTypes, ushortTypes, octetTypes, floatTypes, doubleTypes, 
            stringTypes,  wstringTypes };

        private static readonly Regex MultipleSpaces = new Regex(@" {2,}", RegexOptions.Compiled);

        /** Normalizes a type name converting it into a legal IDL4  type.
         *
         * This function handles common variations of primitive type names. For anything non-primitive
         * it just calls IDL_NormalizeUserDefinedClassifierName
         */
        private static String IDL_NormalizeMemberTypeName(String typeName)
        {
            String normalizedType = MultipleSpaces.Replace(typeName, " ");
            for (int typeFamily = 0; typeFamily < primtiveTypeVariations.GetLength(0); ++typeFamily)
            {
                if (primtiveTypeVariations[typeFamily].Contains(normalizedType.ToLower()))
                {
                    return primtiveTypeVariations[typeFamily][0];
                }
            }

            return IDL_NormalizeUserDefinedClassifierName(normalizedType);
        }


        private static readonly string[] keyAnnotation = new string[] { "Key", "key" };
        private static readonly string[] mustUnderstandAnnotation = new string[] { "must_understand" };

        private static readonly string[] idAnnotation = new string[] { "ID", "id" };
        private static readonly string[] autoidAnnotation = new string[] { "autoid" };
        private static readonly string[] optionalAnnotation = new string[] { "Optional", "optional" };
        private static readonly string[] valueAnnotation = new string[] { "value" };

        private static readonly string[] extensibilityAnnotation = new string[] { "Extensibility", "extensibility" };
        private static readonly string[] finalAnnotation = new string[] { "final" };
        private static readonly string[] mutableAnnotation = new string[] { "mutable" };

        private static readonly string[] defaultAnnotation = new string[] { "default" };
        private static readonly string[] rangeAnnotation = new string[] { "range" };
        private static readonly string[] minAnnotation = new string[] { "min" };
        private static readonly string[] maxAnnotation = new string[] { "max" };
        private static readonly string[] unitAnnotation = new string[] { "unit" };

        private static readonly string[] bitBoundAnnotation = new string[] { "bit_bound" };
        private static readonly string[] externalAnnotation = new string[] { "external" };
        private static readonly string[] nestedAnnotation = new string[] { "nested" };

        private static readonly string[] verbatimAnnotation = new string[] { "verbatim" };

        private static readonly string[] serviceAnnotation = new string[] { "service" };
        private static readonly string[] onewayAnnotation = new string[] { "oneway" };
        private static readonly string[] amiAnnotation = new string[]   { "ami" };

        // Not strictly a IDL3.5, 4, or XTYPES annotation but something users do sometimes
        private static readonly string[] ddsAnnotation = new string[] { "DDS", "dds" };

        private static readonly string[][] builtinAnnotationVariations = {
            keyAnnotation, mustUnderstandAnnotation,
            idAnnotation, autoidAnnotation, optionalAnnotation, valueAnnotation,
            extensibilityAnnotation, finalAnnotation, mutableAnnotation,
            defaultAnnotation, rangeAnnotation, minAnnotation, maxAnnotation, unitAnnotation,
            bitBoundAnnotation, externalAnnotation, nestedAnnotation,
            verbatimAnnotation,
            serviceAnnotation, onewayAnnotation, amiAnnotation,
            ddsAnnotation
        };

        /** Normalizes an annotation type name converting it into a legal IDL4 / Connext DDS annotation.
         *
         * This function handles common variations of capitalization for the builtin annotations. For anything
         * non-built-in it just leaves it unchanged
         */
        private static String IDL_NormalizeAnnotationName(String annotationName)
        {
            String annotationNameLower = annotationName.ToLower();
            for (int annotationType = 0; annotationType < builtinAnnotationVariations.GetLength(0); ++annotationType)
            {
                if ( builtinAnnotationVariations[annotationType].Contains(annotationNameLower) )
                {
                    return builtinAnnotationVariations[annotationType][0];
                }
            }

            return annotationName;
        }

        /**
         * Determines whether this is a model element relevant to Connext DDS and we need to
         * generate code associated with the model element.
         */
        private static bool IsClass(Element e)
        {
            return (e.Type == "Class");
        }

        private static bool IsEmptyClass(Element e)
        {
            return (e.Attributes.Count == 0) && (e.Connectors.Count == 0);
        }


        internal static void setIdlVersion(int p)
        {
            Main.idlVersion = p;
        }

        internal static void setIdlMappingDetail(int p)
        {
            Main.idlMappingDetail = p;
        }

    }
}
